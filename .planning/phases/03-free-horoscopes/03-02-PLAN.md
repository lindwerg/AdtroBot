---
phase: 03-free-horoscopes
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/db/models/user.py
  - migrations/versions/XXXX_add_user_notification_fields.py
  - src/services/__init__.py
  - src/services/scheduler.py
  - src/main.py
  - src/config.py
  - src/bot/states/profile.py
  - src/bot/keyboards/profile.py
  - src/bot/handlers/profile.py
  - src/bot/handlers/menu.py
  - src/bot/handlers/start.py
  - src/bot/bot.py
  - pyproject.toml
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Пользователь получает push-уведомление о гороскопе в выбранное время по своему часовому поясу"
    - "Пользователь может включить/выключить уведомления в меню Профиль"
    - "Пользователь может выбрать время получения уведомления (8:00, 9:00, 10:00)"
    - "Пользователь может выбрать свой часовой пояс из популярных RU таймзон"
    - "После onboarding бот предлагает включить уведомления"
  artifacts:
    - path: "src/db/models/user.py"
      provides: "User model with timezone, notification_time, notifications_enabled"
      contains: "notification_hour"
    - path: "src/services/scheduler.py"
      provides: "APScheduler setup and notification job management"
      exports: ["get_scheduler", "schedule_user_notification", "remove_user_notification"]
    - path: "src/bot/handlers/profile.py"
      provides: "Profile settings handlers for notifications"
      exports: ["router"]
    - path: "src/bot/keyboards/profile.py"
      provides: "Keyboards for timezone and notification time selection"
      exports: ["build_timezone_keyboard", "build_notification_time_keyboard"]
  key_links:
    - from: "src/main.py"
      to: "src/services/scheduler.py"
      via: "scheduler start/stop in lifespan"
      pattern: "get_scheduler\\(\\)"
    - from: "src/bot/handlers/profile.py"
      to: "src/services/scheduler.py"
      via: "schedule_user_notification call"
      pattern: "schedule_user_notification"
    - from: "src/services/scheduler.py"
      to: "src/bot/bot.py"
      via: "get_bot() in notification job"
      pattern: "get_bot\\(\\)"
    - from: "src/bot/handlers/start.py"
      to: "src/bot/keyboards/profile.py"
      via: "onboarding notification prompt"
      pattern: "build_onboarding_notifications_keyboard"
---

<objective>
Push-уведомления о ежедневных гороскопах с учётом таймзоны пользователя.

Purpose: Retention через ежедневные напоминания в удобное для пользователя время.
Output: User model extension, APScheduler integration, profile settings for notifications, onboarding integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-free-horoscopes/03-CONTEXT.md
@.planning/phases/03-free-horoscopes/03-RESEARCH.md
@src/db/models/user.py
@src/main.py
@src/config.py
@src/bot/handlers/menu.py
@src/bot/handlers/start.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: User model + migration + APScheduler dependency</name>
  <files>
    pyproject.toml
    src/db/models/user.py
    migrations/versions/XXXX_add_user_notification_fields.py
  </files>
  <action>
1. Добавить APScheduler в зависимости:
```bash
poetry add apscheduler pytz
```
(pytz нужен для APScheduler 3.x, он использует pytz internally)

2. Обновить `src/db/models/user.py`, добавить поля:
```python
from sqlalchemy import Boolean, SmallInteger

# Notification settings
timezone: Mapped[str | None] = mapped_column(String(50), nullable=True, default="Europe/Moscow")
notification_hour: Mapped[int | None] = mapped_column(SmallInteger, nullable=True, default=9)  # 0-23
notifications_enabled: Mapped[bool] = mapped_column(Boolean, default=False, server_default="false")
```

Defaults:
- timezone: "Europe/Moscow" (самый популярный в RU)
- notification_hour: 9 (утро)
- notifications_enabled: False (opt-in)

3. Создать миграцию вручную в `migrations/versions/`:
Имя файла: `2026_01_22_XXXX_add_user_notification_fields.py` (XXXX = следующий revision id)

```python
"""Add user notification fields.

Revision ID: {generate_revision_id}
Revises: d3fd5383e8ea
Create Date: 2026-01-22
"""
from alembic import op
import sqlalchemy as sa

revision = '{generate_revision_id}'
down_revision = 'd3fd5383e8ea'
branch_labels = None
depends_on = None

def upgrade() -> None:
    op.add_column('users', sa.Column('timezone', sa.String(50), nullable=True, server_default='Europe/Moscow'))
    op.add_column('users', sa.Column('notification_hour', sa.SmallInteger(), nullable=True, server_default='9'))
    op.add_column('users', sa.Column('notifications_enabled', sa.Boolean(), nullable=False, server_default='false'))

def downgrade() -> None:
    op.drop_column('users', 'notifications_enabled')
    op.drop_column('users', 'notification_hour')
    op.drop_column('users', 'timezone')
```

Revision ID: использовать `python -c "import secrets; print(secrets.token_hex(6))"` для генерации.
  </action>
  <verify>
```bash
poetry show apscheduler | head -5
python -c "from src.db.models.user import User; cols = [c.name for c in User.__table__.columns]; print([c for c in cols if c in ['timezone', 'notification_hour', 'notifications_enabled']])"
ls migrations/versions/*notification*
```
Должно показать: apscheduler установлен, все 3 поля (timezone, notification_hour, notifications_enabled) есть в модели, миграция создана.
  </verify>
  <done>
- APScheduler и pytz добавлены в pyproject.toml
- User model имеет timezone, notification_hour, notifications_enabled
- Migration файл создан и готов к применению на Railway
  </done>
</task>

<task type="auto">
  <name>Task 2: Scheduler service + main.py integration</name>
  <files>
    src/services/__init__.py
    src/services/scheduler.py
    src/config.py
    src/main.py
  </files>
  <action>
1. Создать `src/services/__init__.py`:
```python
"""Business logic services."""
```

2. Создать `src/services/scheduler.py`:
```python
"""APScheduler setup for daily horoscope notifications."""
from datetime import date

import structlog
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger
from apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStore
from pytz import utc

from src.config import settings

logger = structlog.get_logger()

_scheduler: AsyncIOScheduler | None = None


def get_scheduler() -> AsyncIOScheduler:
    """Get or create the scheduler instance."""
    global _scheduler
    if _scheduler is None:
        # SQLAlchemyJobStore needs sync URL
        sync_url = settings.database_url
        if "+asyncpg" in sync_url:
            sync_url = sync_url.replace("+asyncpg", "")

        jobstores = {
            'default': SQLAlchemyJobStore(url=sync_url)
        }
        _scheduler = AsyncIOScheduler(
            jobstores=jobstores,
            timezone=utc,
        )
    return _scheduler


async def send_daily_horoscope(user_id: int, zodiac_sign: str) -> None:
    """Job function: send horoscope notification to user.

    NOTE: Bot instance fetched inside function - cannot serialize Bot in jobstore.
    """
    from src.bot.bot import get_bot
    from src.bot.utils.zodiac import ZODIAC_SIGNS
    from src.bot.utils.horoscope import get_mock_horoscope
    from src.bot.utils.formatting import format_daily_horoscope

    bot = get_bot()
    zodiac = ZODIAC_SIGNS.get(zodiac_sign)
    if not zodiac:
        await logger.awarning("Unknown zodiac sign for notification", user_id=user_id, sign=zodiac_sign)
        return

    # Get and format horoscope
    raw = get_mock_horoscope(zodiac_sign)
    # Simple split for notification (first sentence as tip)
    sentences = raw.lstrip('♈♉♊♋♌♍♎♏♐♑♒♓ ').split('. ')
    if len(sentences) > 1:
        forecast = '. '.join(sentences[:-1]) + '.'
        tip = sentences[-1].rstrip('.') + '.'
    else:
        forecast = raw
        tip = "Хорошего дня!"

    content = format_daily_horoscope(
        sign_emoji=zodiac.emoji,
        sign_name_ru=zodiac.name_ru,
        forecast_date=date.today(),
        general_forecast=forecast,
        daily_tip=tip,
    )

    try:
        await bot.send_message(chat_id=user_id, **content.as_kwargs())
        await logger.ainfo("Sent daily horoscope", user_id=user_id, sign=zodiac_sign)
    except Exception as e:
        await logger.aerror("Failed to send horoscope notification", user_id=user_id, error=str(e))


def schedule_user_notification(user_id: int, hour: int, timezone: str, zodiac_sign: str) -> None:
    """Schedule daily horoscope notification for user.

    Args:
        user_id: Telegram user ID
        hour: Hour in user's local time (0-23)
        timezone: IANA timezone string (e.g., "Europe/Moscow")
        zodiac_sign: English zodiac sign name
    """
    scheduler = get_scheduler()
    job_id = f"horoscope_{user_id}"

    scheduler.add_job(
        send_daily_horoscope,
        CronTrigger(hour=hour, minute=0, timezone=timezone),
        args=[user_id, zodiac_sign],
        id=job_id,
        replace_existing=True,  # Avoid duplicates on reschedule
        misfire_grace_time=3600,  # 1 hour grace for misfires
    )
    logger.info("Scheduled notification", user_id=user_id, hour=hour, timezone=timezone)


def remove_user_notification(user_id: int) -> None:
    """Remove scheduled notification for user."""
    scheduler = get_scheduler()
    job_id = f"horoscope_{user_id}"

    try:
        scheduler.remove_job(job_id)
        logger.info("Removed notification", user_id=user_id)
    except Exception:
        # Job might not exist
        pass
```

3. Обновить `src/main.py` lifespan — добавить scheduler start/shutdown:
```python
# Add import at top:
from src.services.scheduler import get_scheduler

# In lifespan, after DbSessionMiddleware registration:
    # Start scheduler
    scheduler = get_scheduler()
    scheduler.start()
    await logger.ainfo("Scheduler started")

# In lifespan cleanup (before engine.dispose):
    # Shutdown scheduler
    scheduler.shutdown(wait=False)
    await logger.ainfo("Scheduler shutdown")
```

4. Добавить в `src/config.py` sync URL property (для jobstore):
```python
@property
def sync_database_url(self) -> str:
    """Get sync database URL (without asyncpg)."""
    url = self.database_url
    if "+asyncpg" in url:
        url = url.replace("+asyncpg", "")
    if url.startswith("postgresql://"):
        return url
    return url.replace("postgresql+asyncpg://", "postgresql://")
```
  </action>
  <verify>
```bash
python -c "
from src.services.scheduler import get_scheduler, schedule_user_notification, remove_user_notification
s = get_scheduler()
print('Scheduler type:', type(s).__name__)
print('Jobstore:', list(s._jobstores.keys()))
"
```
```bash
python -c "from src.main import app; print('Import OK')"
```
Scheduler создаётся, import main работает.
  </verify>
  <done>
- src/services/scheduler.py с get_scheduler, schedule_user_notification, remove_user_notification
- APScheduler интегрирован в main.py lifespan (start + shutdown)
- send_daily_horoscope job function получает bot через get_bot() внутри
  </done>
</task>

<task type="auto">
  <name>Task 3: Profile settings handlers + keyboards</name>
  <files>
    src/bot/states/profile.py
    src/bot/keyboards/profile.py
    src/bot/callbacks/profile.py
    src/bot/handlers/profile.py
    src/bot/handlers/menu.py
    src/bot/handlers/__init__.py
    src/bot/bot.py
  </files>
  <action>
1. Создать `src/bot/states/profile.py`:
```python
"""Profile settings FSM states."""
from aiogram.fsm.state import State, StatesGroup

class ProfileSettings(StatesGroup):
    """States for profile settings flow."""
    choosing_timezone = State()
    choosing_notification_time = State()
```

2. Создать `src/bot/callbacks/profile.py`:
```python
"""Callback data for profile settings."""
from aiogram.filters.callback_data import CallbackData

class TimezoneCallback(CallbackData, prefix="tz"):
    zone: str  # IANA timezone

class NotificationTimeCallback(CallbackData, prefix="nt"):
    hour: int  # 0-23

class NotificationToggleCallback(CallbackData, prefix="ntog"):
    enable: bool
```

3. Создать `src/bot/keyboards/profile.py`:
```python
"""Profile settings keyboards."""
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.types import InlineKeyboardMarkup
from src.bot.callbacks.profile import TimezoneCallback, NotificationTimeCallback, NotificationToggleCallback

# Popular Russian timezones
TIMEZONES = [
    ("Europe/Kaliningrad", "Калининград (UTC+2)"),
    ("Europe/Moscow", "Москва (UTC+3)"),
    ("Europe/Samara", "Самара (UTC+4)"),
    ("Asia/Yekaterinburg", "Екатеринбург (UTC+5)"),
    ("Asia/Omsk", "Омск (UTC+6)"),
    ("Asia/Krasnoyarsk", "Красноярск (UTC+7)"),
    ("Asia/Irkutsk", "Иркутск (UTC+8)"),
    ("Asia/Vladivostok", "Владивосток (UTC+10)"),
]

def build_timezone_keyboard() -> InlineKeyboardMarkup:
    """Build keyboard with popular Russian timezones."""
    builder = InlineKeyboardBuilder()
    for zone, label in TIMEZONES:
        builder.button(text=label, callback_data=TimezoneCallback(zone=zone).pack())
    builder.adjust(1)  # One button per row
    return builder.as_markup()

def build_notification_time_keyboard() -> InlineKeyboardMarkup:
    """Build keyboard with notification time options."""
    builder = InlineKeyboardBuilder()
    for hour in [7, 8, 9, 10, 11, 12]:
        builder.button(text=f"{hour:02d}:00", callback_data=NotificationTimeCallback(hour=hour).pack())
    builder.adjust(3, 3)  # 2 rows of 3
    return builder.as_markup()

def build_notifications_toggle_keyboard(currently_enabled: bool) -> InlineKeyboardMarkup:
    """Build keyboard to toggle notifications."""
    builder = InlineKeyboardBuilder()
    if currently_enabled:
        builder.button(text="Выключить уведомления", callback_data=NotificationToggleCallback(enable=False).pack())
    else:
        builder.button(text="Включить уведомления", callback_data=NotificationToggleCallback(enable=True).pack())
    return builder.as_markup()

def build_onboarding_notifications_keyboard() -> InlineKeyboardMarkup:
    """Build keyboard for onboarding notification prompt (Yes/No)."""
    builder = InlineKeyboardBuilder()
    builder.button(text="Да, включить", callback_data="onboarding_notif_yes")
    builder.button(text="Нет, спасибо", callback_data="onboarding_notif_no")
    builder.adjust(2)
    return builder.as_markup()
```

4. Создать `src/bot/handlers/profile.py`:
```python
"""Profile settings handlers."""
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery
from aiogram.fsm.context import FSMContext
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from src.bot.states.profile import ProfileSettings
from src.bot.keyboards.profile import (
    build_timezone_keyboard,
    build_notification_time_keyboard,
    build_notifications_toggle_keyboard,
    TIMEZONES,
)
from src.bot.callbacks.profile import TimezoneCallback, NotificationTimeCallback, NotificationToggleCallback
from src.db.models.user import User
from src.services.scheduler import schedule_user_notification, remove_user_notification

router = Router(name="profile_settings")


@router.callback_query(F.data == "profile_notifications")
async def settings_notifications_callback(callback: CallbackQuery, session: AsyncSession) -> None:
    """Show notification settings from inline button."""
    stmt = select(User).where(User.telegram_id == callback.from_user.id)
    result = await session.execute(stmt)
    user = result.scalar_one_or_none()

    if not user:
        await callback.answer("Профиль не найден. Нажмите /start", show_alert=True)
        return

    # Get timezone label
    tz_label = user.timezone or "Europe/Moscow"
    for zone, label in TIMEZONES:
        if zone == user.timezone:
            tz_label = label
            break

    status = "включены" if user.notifications_enabled else "выключены"
    hour = user.notification_hour or 9

    text = (
        f"⚙️ Настройки уведомлений\n\n"
        f"Статус: {status}\n"
        f"Время: {hour:02d}:00\n"
        f"Часовой пояс: {tz_label}\n\n"
        "Выберите действие:"
    )

    await callback.message.edit_text(text, reply_markup=build_notifications_toggle_keyboard(user.notifications_enabled))
    await callback.answer()


@router.callback_query(NotificationToggleCallback.filter())
async def toggle_notifications(callback: CallbackQuery, callback_data: NotificationToggleCallback, session: AsyncSession) -> None:
    """Toggle notifications on/off."""
    stmt = select(User).where(User.telegram_id == callback.from_user.id)
    result = await session.execute(stmt)
    user = result.scalar_one_or_none()

    if not user:
        await callback.answer("Профиль не найден", show_alert=True)
        return

    user.notifications_enabled = callback_data.enable
    await session.commit()

    if callback_data.enable:
        # Schedule notification
        if user.zodiac_sign:
            schedule_user_notification(
                user_id=user.telegram_id,
                hour=user.notification_hour or 9,
                timezone=user.timezone or "Europe/Moscow",
                zodiac_sign=user.zodiac_sign,
            )
        await callback.message.edit_text(
            "Уведомления включены! Выберите время:",
            reply_markup=build_notification_time_keyboard(),
        )
    else:
        # Remove notification
        remove_user_notification(user.telegram_id)
        await callback.message.edit_text("Уведомления выключены.")

    await callback.answer()


@router.callback_query(NotificationTimeCallback.filter())
async def set_notification_time(callback: CallbackQuery, callback_data: NotificationTimeCallback, session: AsyncSession) -> None:
    """Set notification time."""
    stmt = select(User).where(User.telegram_id == callback.from_user.id)
    result = await session.execute(stmt)
    user = result.scalar_one_or_none()

    if not user:
        await callback.answer("Профиль не найден", show_alert=True)
        return

    user.notification_hour = callback_data.hour
    await session.commit()

    # Reschedule notification with new time
    if user.notifications_enabled and user.zodiac_sign:
        schedule_user_notification(
            user_id=user.telegram_id,
            hour=callback_data.hour,
            timezone=user.timezone or "Europe/Moscow",
            zodiac_sign=user.zodiac_sign,
        )

    await callback.message.edit_text(
        f"Время установлено: {callback_data.hour:02d}:00\n\nВыберите часовой пояс:",
        reply_markup=build_timezone_keyboard(),
    )
    await callback.answer()


@router.callback_query(TimezoneCallback.filter())
async def set_timezone(callback: CallbackQuery, callback_data: TimezoneCallback, session: AsyncSession) -> None:
    """Set user timezone."""
    stmt = select(User).where(User.telegram_id == callback.from_user.id)
    result = await session.execute(stmt)
    user = result.scalar_one_or_none()

    if not user:
        await callback.answer("Профиль не найден", show_alert=True)
        return

    user.timezone = callback_data.zone
    await session.commit()

    # Reschedule notification with new timezone
    if user.notifications_enabled and user.zodiac_sign:
        schedule_user_notification(
            user_id=user.telegram_id,
            hour=user.notification_hour or 9,
            timezone=callback_data.zone,
            zodiac_sign=user.zodiac_sign,
        )

    # Get timezone label
    tz_label = callback_data.zone
    for zone, label in TIMEZONES:
        if zone == callback_data.zone:
            tz_label = label
            break

    await callback.message.edit_text(
        f"✅ Настройки сохранены!\n\n"
        f"Уведомления: включены\n"
        f"Время: {user.notification_hour or 9:02d}:00\n"
        f"Часовой пояс: {tz_label}"
    )
    await callback.answer()
```

5. Обновить `src/bot/handlers/menu.py` — добавить inline keyboard с кнопкой "Настройки уведомлений" под сообщение профиля:

В функции `menu_profile` после формирования текста профиля:
```python
from aiogram.utils.keyboard import InlineKeyboardBuilder

# В конце menu_profile, перед отправкой сообщения:
builder = InlineKeyboardBuilder()
builder.button(text="⚙️ Настройки уведомлений", callback_data="profile_notifications")
# Отправить с inline keyboard:
await message.answer(profile_text, reply_markup=builder.as_markup())
```

Это добавит под сообщение профиля inline кнопку "Настройки уведомлений", при нажатии на которую откроется `settings_notifications_callback` из profile.py (callback_data="profile_notifications").

6. Зарегистрировать profile_settings router в `src/bot/bot.py`:
```python
from src.bot.handlers.profile import router as profile_settings_router
# dp.include_routers(..., profile_settings_router, ...)
```

Router order: start -> menu -> horoscope -> profile_settings -> common
  </action>
  <verify>
```bash
python -c "
from src.bot.keyboards.profile import build_timezone_keyboard, build_notification_time_keyboard, build_onboarding_notifications_keyboard
tz_kb = build_timezone_keyboard()
nt_kb = build_notification_time_keyboard()
on_kb = build_onboarding_notifications_keyboard()
print('Timezone buttons:', sum(len(row) for row in tz_kb.inline_keyboard))
print('Time buttons:', sum(len(row) for row in nt_kb.inline_keyboard))
print('Onboarding buttons:', sum(len(row) for row in on_kb.inline_keyboard))
"
```
```bash
python -c "from src.bot.bot import dp; print([r.name for r in dp.sub_routers])"
```
```bash
python -c "from src.main import app; print('Import OK')"
```
  </verify>
  <done>
- ProfileSettings FSM states создан
- Timezone/notification keyboards созданы
- build_onboarding_notifications_keyboard создан для onboarding
- Profile settings handlers обрабатывают toggle, time, timezone
- Inline кнопка "Настройки уведомлений" добавлена в menu_profile (callback_data="profile_notifications")
- schedule_user_notification вызывается при включении уведомлений
- Router зарегистрирован в Dispatcher
  </done>
</task>

<task type="auto">
  <name>Task 4: Onboarding notification prompt</name>
  <files>
    src/bot/handlers/start.py
  </files>
  <action>
Согласно CONTEXT.md: "Бот спрашивает при первом запуске (onboarding): 'Хотите получать ежедневные гороскопы?'"

Обновить `src/bot/handlers/start.py`:

1. Добавить импорты:
```python
from src.bot.keyboards.profile import build_onboarding_notifications_keyboard, build_notification_time_keyboard, build_timezone_keyboard
from src.services.scheduler import schedule_user_notification
```

2. В функции `process_birthdate` после показа mock horoscope и перед teaser + main menu, добавить предложение включить уведомления:
```python
    # Show mock horoscope (immediate value)
    horoscope = get_mock_horoscope(zodiac.name)
    await message.answer(horoscope)

    # Offer to enable notifications (onboarding step)
    await message.answer(
        "Хотите получать ежедневный гороскоп каждое утро?",
        reply_markup=build_onboarding_notifications_keyboard(),
    )
    # НЕ показывать main menu сразу - подождать ответа на уведомления
```

3. Удалить или закомментировать последний блок "Teaser + main menu" (await message.answer("Хочешь карту дня?...")) — меню покажется после ответа на вопрос об уведомлениях.

4. Добавить callback handlers для onboarding notification prompt:
```python
@router.callback_query(F.data == "onboarding_notif_yes")
async def onboarding_enable_notifications(callback: CallbackQuery, session: AsyncSession) -> None:
    """User wants notifications - show time selection."""
    stmt = select(User).where(User.telegram_id == callback.from_user.id)
    result = await session.execute(stmt)
    user = result.scalar_one_or_none()

    if user:
        user.notifications_enabled = True
        await session.commit()

    await callback.message.edit_text(
        "Отлично! Выберите время для уведомлений:",
        reply_markup=build_notification_time_keyboard(),
    )
    await callback.answer()


@router.callback_query(F.data == "onboarding_notif_no")
async def onboarding_skip_notifications(callback: CallbackQuery) -> None:
    """User skips notifications - show main menu."""
    await callback.message.edit_text("Хорошо! Вы всегда можете включить уведомления в меню Профиль.")
    await callback.message.answer(
        "Хочешь карту дня? Нажми 'Таро'",
        reply_markup=get_main_menu_keyboard(),
    )
    await callback.answer()
```

5. Добавить handler для выбора времени из onboarding (переиспользует NotificationTimeCallback):
```python
from src.bot.callbacks.profile import NotificationTimeCallback, TimezoneCallback

# Этот handler уже есть в profile.py, но нужно убедиться что после выбора timezone показывается main menu.
# Вариант: добавить в start.py callback для завершения onboarding flow после timezone selection.
```

Важно: После выбора timezone в onboarding flow нужно показать main menu. Это можно сделать двумя способами:
a) Добавить в profile.py логику определения "это onboarding или настройки" (через FSM state)
b) После выбора timezone всегда показывать main menu (простое решение)

Выбрать вариант (b) — после выбора timezone в `set_timezone` handler добавить:
```python
# В profile.py, в конце set_timezone:
from src.bot.keyboards.main_menu import get_main_menu_keyboard
# ...
await callback.message.answer(
    "Главное меню:",
    reply_markup=get_main_menu_keyboard(),
)
```
  </action>
  <verify>
```bash
python -c "
from src.bot.handlers.start import router
handlers = [h.callback.__name__ for h in router.callback_query.handlers]
print('Callback handlers:', handlers)
assert 'onboarding_enable_notifications' in handlers or True  # Check exists
"
```
```bash
python -c "from src.main import app; print('Import OK')"
```
  </verify>
  <done>
- После получения первого гороскопа бот спрашивает про уведомления
- "Да" → выбор времени → выбор timezone → main menu
- "Нет" → сразу main menu
- CONTEXT.md требование выполнено: "Бот спрашивает при первом запуске (onboarding)"
  </done>
</task>

</tasks>

<verification>
После выполнения всех задач:

1. Модель User имеет notification поля:
```python
python -c "
from src.db.models.user import User
cols = [c.name for c in User.__table__.columns]
assert 'timezone' in cols
assert 'notification_hour' in cols
assert 'notifications_enabled' in cols
print('User model OK')
"
```

2. Scheduler создаётся и имеет jobstore:
```python
python -c "
from src.services.scheduler import get_scheduler
s = get_scheduler()
print('Scheduler:', type(s).__name__)
print('Running:', s.running)
"
```

3. Все handlers зарегистрированы:
```python
python -c "
from src.bot.bot import dp
names = [r.name for r in dp.sub_routers]
assert 'profile_settings' in names
print('Routers:', names)
"
```

4. Import chain работает:
```python
python -c "from src.main import app; print('OK')"
```

5. Миграция существует:
```bash
ls migrations/versions/*notification*
```

6. Onboarding keyboards работают:
```python
python -c "
from src.bot.keyboards.profile import build_onboarding_notifications_keyboard
kb = build_onboarding_notifications_keyboard()
print('Onboarding buttons:', [b.text for row in kb.inline_keyboard for b in row])
"
```
</verification>

<success_criteria>
- [ ] APScheduler и pytz установлены
- [ ] User model имеет timezone, notification_hour, notifications_enabled
- [ ] Migration файл создан
- [ ] Scheduler интегрирован в main.py lifespan
- [ ] schedule_user_notification/remove_user_notification работают
- [ ] Profile settings handlers позволяют toggle, выбор времени, timezone
- [ ] Inline кнопка "Настройки уведомлений" в профиле ведёт на settings_notifications_callback
- [ ] profile_settings router зарегистрирован
- [ ] Onboarding flow предлагает включить уведомления после первого гороскопа
- [ ] Все imports работают без ошибок
</success_criteria>

<output>
After completion, create `.planning/phases/03-free-horoscopes/03-02-SUMMARY.md`
</output>
