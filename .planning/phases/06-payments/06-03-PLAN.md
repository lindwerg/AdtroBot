---
phase: 06-payments
plan: 03
type: execute
wave: 3
depends_on: ["06-02"]
files_modified:
  - src/bot/handlers/subscription.py
  - src/bot/keyboards/subscription.py
  - src/bot/callbacks/subscription.py
  - src/bot/handlers/menu.py
  - src/bot/handlers/profile.py
  - src/bot/handlers/tarot.py
  - src/bot/handlers/__init__.py
  - src/bot/bot.py
  - src/services/scheduler.py
autonomous: true

must_haves:
  truths:
    - "Пользователь нажимает Подписка и видит тарифы"
    - "Пользователь получает ссылку на оплату ЮКасса"
    - "Пользователь может отменить подписку в Профиле"
    - "Лимит раскладов проверяется атомарно"
    - "Пользователь получает уведомление за 3 дня до истечения"
  artifacts:
    - path: "src/bot/handlers/subscription.py"
      provides: "Subscription flow handlers"
      contains: "show_plans"
    - path: "src/bot/keyboards/subscription.py"
      provides: "Subscription keyboards"
      contains: "get_plans_keyboard"
    - path: "src/bot/handlers/tarot.py"
      provides: "Updated limit check"
      contains: "daily_spread_limit"
  key_links:
    - from: "src/bot/handlers/subscription.py"
      to: "src/services/payment/client.py"
      via: "create_payment call"
      pattern: "create_payment"
    - from: "src/bot/handlers/tarot.py"
      to: "src/db/models/user.py"
      via: "atomic limit check"
      pattern: "daily_spread_limit"
---

<objective>
Subscription Handlers + Profile + Notifications

Purpose: Реализовать user-facing flow подписки - выбор тарифа, оплата, отмена, уведомления об истечении.

Output:
- Subscription handlers (выбор плана, получение ссылки на оплату)
- Profile integration (статус подписки, кнопка отмены)
- Tarot limit checks using daily_spread_limit
- Notification jobs за 3 дня до истечения
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-payments/06-CONTEXT.md
@.planning/phases/06-payments/06-RESEARCH.md
@.planning/phases/06-payments/06-01-SUMMARY.md
@.planning/phases/06-payments/06-02-SUMMARY.md

@src/bot/handlers/menu.py
@src/bot/handlers/profile.py
@src/bot/handlers/tarot.py
@src/bot/bot.py
@src/services/scheduler.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Subscription Handlers + Keyboards</name>
  <files>
    src/bot/handlers/subscription.py
    src/bot/keyboards/subscription.py
    src/bot/callbacks/subscription.py
    src/bot/handlers/menu.py
    src/bot/handlers/__init__.py
    src/bot/bot.py
  </files>
  <action>
1. Create src/bot/callbacks/subscription.py:
   ```python
   """Subscription callback data."""
   from aiogram.filters.callback_data import CallbackData


   class SubscriptionCallback(CallbackData, prefix="sub"):
       """Callback for subscription actions."""
       action: str  # "plan", "cancel", "confirm_cancel"
       plan: str = ""  # "monthly", "yearly"
   ```

2. Create src/bot/keyboards/subscription.py:
   ```python
   """Subscription keyboards."""
   from aiogram.types import InlineKeyboardMarkup
   from aiogram.utils.keyboard import InlineKeyboardBuilder

   from src.bot.callbacks.subscription import SubscriptionCallback


   def get_plans_keyboard() -> InlineKeyboardMarkup:
       """Build subscription plans keyboard."""
       builder = InlineKeyboardBuilder()

       builder.button(
           text="Месяц — 299 р.",
           callback_data=SubscriptionCallback(action="plan", plan="monthly"),
       )
       builder.button(
           text="Год — 2499 р. (-30%)",
           callback_data=SubscriptionCallback(action="plan", plan="yearly"),
       )
       builder.adjust(1)

       return builder.as_markup()


   def get_cancel_confirmation_keyboard() -> InlineKeyboardMarkup:
       """Build cancel confirmation keyboard with retention offer."""
       builder = InlineKeyboardBuilder()

       builder.button(
           text="Да, отменить",
           callback_data=SubscriptionCallback(action="confirm_cancel"),
       )
       builder.button(
           text="Нет, остаюсь",
           callback_data=SubscriptionCallback(action="keep"),
       )
       builder.adjust(1)

       return builder.as_markup()
   ```

3. Create src/bot/handlers/subscription.py:
   ```python
   """Subscription flow handlers."""
   from aiogram import F, Router
   from aiogram.types import CallbackQuery, Message
   from sqlalchemy import select
   from sqlalchemy.ext.asyncio import AsyncSession

   from src.bot.callbacks.subscription import SubscriptionCallback
   from src.bot.keyboards.subscription import (
       get_cancel_confirmation_keyboard,
       get_plans_keyboard,
   )
   from src.db.models.user import User
   from src.services.payment import (
       PLAN_PRICES,
       PaymentPlan,
       cancel_subscription,
       create_payment,
       get_user_subscription,
   )
   from src.services.payment.schemas import PLAN_PRICES_STR

   router = Router(name="subscription")

   PREMIUM_FEATURES = """
   Премиум-подписка открывает:

   - 20 раскладов таро в день (вместо 1)
   - Детальные гороскопы по сферам жизни
   - Персональный прогноз на основе натальной карты
   - Кельтский крест (расклад на 10 карт)
   - Приоритетная поддержка
   """


   async def show_plans(message: Message, session: AsyncSession) -> None:
       """Show subscription plans."""
       # Check if already premium
       stmt = select(User).where(User.telegram_id == message.from_user.id)
       result = await session.execute(stmt)
       user = result.scalar_one_or_none()

       if user and user.is_premium and user.premium_until:
           until_str = user.premium_until.strftime("%d.%m.%Y")
           await message.answer(
               f"У вас уже есть премиум-подписка до {until_str}\n\n"
               "Хотите продлить?"
           )

       await message.answer(
           PREMIUM_FEATURES + "\n\nВыберите тариф:",
           reply_markup=get_plans_keyboard(),
       )


   @router.callback_query(SubscriptionCallback.filter(F.action == "plan"))
   async def handle_plan_selection(
       callback: CallbackQuery,
       callback_data: SubscriptionCallback,
       session: AsyncSession,
   ) -> None:
       """Handle plan selection - create payment and send link."""
       await callback.answer()

       plan = PaymentPlan(callback_data.plan)
       price = PLAN_PRICES_STR[plan]

       plan_names = {
           PaymentPlan.MONTHLY: "Месячная подписка",
           PaymentPlan.YEARLY: "Годовая подписка",
       }

       try:
           # Create payment with method saving for recurring
           payment = await create_payment(
               user_id=callback.from_user.id,
               amount=price,
               description=f"AdtroBot {plan_names[plan]}",
               save_payment_method=True,
               metadata={
                   "plan_type": plan.value,
               },
           )

           confirmation_url = payment.confirmation.confirmation_url

           await callback.message.edit_text(
               f"Отлично! Перейдите по ссылке для оплаты:\n\n"
               f"{confirmation_url}\n\n"
               f"После оплаты подписка активируется автоматически."
           )

       except Exception as e:
           await callback.message.edit_text(
               "Произошла ошибка при создании платежа. "
               "Попробуйте позже или напишите в поддержку."
           )


   @router.callback_query(SubscriptionCallback.filter(F.action == "cancel"))
   async def handle_cancel_request(
       callback: CallbackQuery,
       session: AsyncSession,
   ) -> None:
       """Show cancel confirmation with retention offer."""
       await callback.answer()

       subscription = await get_user_subscription(session, callback.from_user.id)

       if not subscription:
           await callback.message.edit_text("У вас нет активной подписки.")
           return

       until_str = subscription.current_period_end.strftime("%d.%m.%Y")

       await callback.message.edit_text(
           f"Вы уверены, что хотите отменить подписку?\n\n"
           f"Доступ сохранится до {until_str}.\n\n"
           "Если передумаете — напишите нам, дадим скидку 20%!",
           reply_markup=get_cancel_confirmation_keyboard(),
       )


   @router.callback_query(SubscriptionCallback.filter(F.action == "confirm_cancel"))
   async def handle_confirm_cancel(
       callback: CallbackQuery,
       session: AsyncSession,
   ) -> None:
       """Confirm subscription cancellation."""
       await callback.answer()

       subscription = await cancel_subscription(session, callback.from_user.id)

       if subscription:
           until_str = subscription.current_period_end.strftime("%d.%m.%Y")
           await callback.message.edit_text(
               f"Подписка отменена.\n\n"
               f"Премиум-доступ сохранится до {until_str}.\n"
               f"Мы будем рады видеть вас снова!"
           )
       else:
           await callback.message.edit_text("Подписка не найдена.")


   @router.callback_query(SubscriptionCallback.filter(F.action == "keep"))
   async def handle_keep_subscription(callback: CallbackQuery) -> None:
       """User decided to keep subscription."""
       await callback.answer("Отлично! Рады, что остаётесь с нами!")
       await callback.message.edit_text(
           "Подписка сохранена. Спасибо, что вы с нами!"
       )
   ```

4. Update src/bot/handlers/menu.py - replace menu_subscription:
   ```python
   # Add import at top:
   from src.bot.handlers.subscription import show_plans

   # Replace menu_subscription handler:
   @router.message(F.text == "Подписка")
   async def menu_subscription(message: Message, session: AsyncSession) -> None:
       """Handle 'Подписка' button press."""
       await show_plans(message, session)
   ```

5. Update src/bot/handlers/__init__.py - add subscription_router:
   ```python
   from src.bot.handlers.subscription import router as subscription_router

   __all__ = [
       # ... existing exports ...
       "subscription_router",
   ]
   ```

6. Update src/bot/bot.py - register subscription router:
   ```python
   from src.bot.handlers import (
       # ... existing imports ...
       subscription_router,
   )

   dp.include_routers(
       start_router,
       menu_router,
       subscription_router,  # Add before horoscope
       horoscope_router,
       tarot_router,
       profile_settings_router,
       common_router,
   )
   ```
  </action>
  <verify>
    poetry run python -c "from src.bot.handlers.subscription import router; print('Subscription handlers OK')"
    poetry run python -c "from src.bot.bot import dp; print([r.name for r in dp.chain_tail])"
    # Should include 'subscription'
    poetry run ruff check src/bot/
  </verify>
  <done>
    - SubscriptionCallback with actions: plan, cancel, confirm_cancel, keep
    - get_plans_keyboard shows monthly/yearly options
    - show_plans shows features and keyboard
    - handle_plan_selection creates payment and returns URL
    - Cancel flow with retention offer
    - Menu "Подписка" calls show_plans
    - Router registered in dp
  </done>
</task>

<task type="auto">
  <name>Task 2: Profile + Limits + Notifications</name>
  <files>
    src/bot/handlers/profile.py
    src/bot/handlers/tarot.py
    src/services/scheduler.py
  </files>
  <action>
1. Update src/bot/handlers/profile.py - add subscription status and cancel button:
   ```python
   # Add imports:
   from src.bot.callbacks.subscription import SubscriptionCallback
   from src.services.payment import get_user_subscription

   # Update menu_profile function to show subscription status:
   # After "Дата рождения" line, add:

   # Subscription status
   subscription = await get_user_subscription(session, message.from_user.id)
   if subscription and user.is_premium:
       until_str = user.premium_until.strftime("%d.%m.%Y") if user.premium_until else "N/A"
       status_emoji = ""
       if subscription.status == "active":
           status_emoji = "active"
           lines.append(f"\nПодписка: Премиум до {until_str}")
       elif subscription.status == "canceled":
           status_emoji = "canceled"
           lines.append(f"\nПодписка: Отменена (доступ до {until_str})")
       elif subscription.status == "trial":
           lines.append(f"\nПодписка: Пробный период до {until_str}")

       # Add cancel button if active (not already canceled)
       if subscription.status in ("active", "trial"):
           builder.button(
               text="Отменить подписку",
               callback_data=SubscriptionCallback(action="cancel"),
           )
   else:
       lines.append("\nПодписка: Бесплатный тариф")
       lines.append(f"Раскладов сегодня: {user.tarot_spread_count}/{user.daily_spread_limit}")
   ```

2. Update src/bot/handlers/tarot.py - use daily_spread_limit from user:
   Find the limit check and update to use user.daily_spread_limit:

   ```python
   # In the spread handler, replace hardcoded limit with:
   if user.tarot_spread_count >= user.daily_spread_limit:
       # Show limit reached message
       await message.answer(
           f"Вы использовали все расклады на сегодня ({user.daily_spread_limit}).\n\n"
           "Оформите подписку для 20 раскладов в день!"
       )
       return
   ```

   Also ensure atomic increment:
   ```python
   # Before doing spread, increment atomically:
   from sqlalchemy import update

   # Atomic increment with limit check
   stmt = (
       update(User)
       .where(
           User.telegram_id == message.from_user.id,
           User.tarot_spread_count < User.daily_spread_limit,
       )
       .values(tarot_spread_count=User.tarot_spread_count + 1)
       .returning(User.tarot_spread_count)
   )
   result = await session.execute(stmt)
   new_count = result.scalar_one_or_none()

   if new_count is None:
       # Limit exceeded (race condition protection)
       await message.answer(...)
       return
   ```

3. Update src/services/scheduler.py - add subscription expiry notification job:
   ```python
   # Add imports:
   from datetime import timedelta
   from sqlalchemy import select, and_

   from src.db.models.subscription import Subscription
   from src.db.models.user import User

   # Add job function:
   async def check_expiring_subscriptions():
       """
       Check for subscriptions expiring in 3 days and send notifications.
       Runs daily at 10:00 Moscow time.
       """
       from src.bot.bot import get_bot
       from src.db.engine import async_session_maker

       async with async_session_maker() as session:
           # Find subscriptions expiring in 3 days
           now = datetime.now(timezone.utc)
           three_days = now + timedelta(days=3)
           four_days = now + timedelta(days=4)

           stmt = (
               select(Subscription, User)
               .join(User, User.id == Subscription.user_id)
               .where(
                   and_(
                       Subscription.status.in_(["active", "trial"]),
                       Subscription.current_period_end >= three_days,
                       Subscription.current_period_end < four_days,
                   )
               )
           )

           result = await session.execute(stmt)
           expiring = result.all()

           if not expiring:
               return

           bot = get_bot()

           for subscription, user in expiring:
               try:
                   end_date = subscription.current_period_end.strftime("%d.%m.%Y")
                   await bot.send_message(
                       user.telegram_id,
                       f"Напоминаем: ваша подписка истекает {end_date}.\n\n"
                       "Продлите сейчас, чтобы не потерять премиум-функции!"
                   )
               except Exception:
                   pass  # User might have blocked bot


   # In get_scheduler(), add the job:
   # After existing jobs, add:
   scheduler.add_job(
       check_expiring_subscriptions,
       "cron",
       hour=10,
       minute=0,
       timezone="Europe/Moscow",
       id="check_expiring_subscriptions",
       replace_existing=True,
   )
   ```
  </action>
  <verify>
    poetry run python -c "from src.bot.handlers.profile import menu_profile; print('Profile OK')"
    poetry run python -c "from src.services.scheduler import get_scheduler; s = get_scheduler(); print([j.id for j in s.get_jobs()])"
    # Should include 'check_expiring_subscriptions'
    poetry run ruff check src/
  </verify>
  <done>
    - Profile shows subscription status and expiry date
    - Profile shows "Отменить подписку" button if active
    - Profile shows remaining spreads for free users
    - Tarot spread uses user.daily_spread_limit (not hardcoded)
    - Atomic limit check prevents race conditions
    - Scheduler job sends notification 3 days before expiry
  </done>
</task>

</tasks>

<verification>
1. `poetry run python -c "from src.bot.handlers.subscription import show_plans; print('OK')"`
2. `poetry run python -c "from src.bot.bot import dp; names = [r.name for r in dp.chain_tail]; assert 'subscription' in names; print('Router OK')"`
3. `poetry run python -c "from src.services.scheduler import get_scheduler; s = get_scheduler(); jobs = [j.id for j in s.get_jobs()]; assert 'check_expiring_subscriptions' in jobs; print('Scheduler OK')"`
4. `poetry run ruff check src/` passes
</verification>

<success_criteria>
- "Подписка" button shows premium features and plan selection
- Plan selection creates YooKassa payment and returns URL
- Cancel flow has retention offer ("скидка 20% если останетесь")
- Profile shows subscription status, expiry date, cancel button
- Free users see remaining spreads count in profile
- Tarot spread limit uses user.daily_spread_limit (1 free, 20 premium)
- Atomic limit check prevents race conditions
- Scheduler sends notification 3 days before subscription expiry
- ruff check passes
</success_criteria>

<output>
After completion, create `.planning/phases/06-payments/06-03-SUMMARY.md`
</output>
