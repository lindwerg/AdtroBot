---
phase: 06-payments
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/services/payment/__init__.py
  - src/services/payment/client.py
  - src/services/payment/service.py
  - src/services/payment/schemas.py
  - src/main.py
autonomous: true

must_haves:
  truths:
    - "YooKassa API вызывается async через to_thread"
    - "Webhook возвращает HTTP 200 немедленно"
    - "Webhook idempotent - дубликаты игнорируются"
    - "Статус подписки обновляется при успешной оплате"
    - "payment_method_id сохраняется для recurring"
  artifacts:
    - path: "src/services/payment/client.py"
      provides: "Async YooKassa client wrapper"
      contains: "asyncio.to_thread"
    - path: "src/services/payment/service.py"
      provides: "Subscription business logic"
      contains: "def activate_subscription"
    - path: "src/main.py"
      provides: "Webhook endpoint"
      contains: "/webhook/yookassa"
  key_links:
    - from: "src/main.py"
      to: "src/services/payment/service.py"
      via: "BackgroundTasks.add_task"
      pattern: "background_tasks\\.add_task"
    - from: "src/services/payment/service.py"
      to: "src/db/models/subscription.py"
      via: "SQLAlchemy ORM"
      pattern: "Subscription"
---

<objective>
Payment Service + YooKassa Webhook

Purpose: Реализовать async-обёртку для YooKassa SDK и webhook endpoint для обработки уведомлений об оплате.

Output:
- Async YooKassa client (create_payment, create_recurring_payment)
- Subscription service (activate, cancel, check_status)
- Webhook endpoint с idempotent обработкой и IP whitelist
- Background processing для heavy operations
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-payments/06-CONTEXT.md
@.planning/phases/06-payments/06-RESEARCH.md
@.planning/phases/06-payments/06-01-SUMMARY.md

@src/config.py
@src/db/models/subscription.py
@src/db/models/payment.py
@src/db/models/user.py
@src/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: YooKassa Async Client + Schemas</name>
  <files>
    src/services/payment/__init__.py
    src/services/payment/client.py
    src/services/payment/schemas.py
  </files>
  <action>
1. Create src/services/payment/__init__.py:
   ```python
   from src.services.payment.client import (
       create_payment,
       create_recurring_payment,
       cancel_recurring,
   )
   from src.services.payment.service import (
       activate_subscription,
       cancel_subscription,
       process_webhook_event,
       get_user_subscription,
   )
   from src.services.payment.schemas import (
       PaymentPlan,
       PLAN_PRICES,
   )

   __all__ = [
       "create_payment",
       "create_recurring_payment",
       "cancel_recurring",
       "activate_subscription",
       "cancel_subscription",
       "process_webhook_event",
       "get_user_subscription",
       "PaymentPlan",
       "PLAN_PRICES",
   ]
   ```

2. Create src/services/payment/schemas.py:
   ```python
   from enum import Enum
   from pydantic import BaseModel

   class PaymentPlan(str, Enum):
       MONTHLY = "monthly"
       YEARLY = "yearly"

   # Prices in kopeks
   PLAN_PRICES = {
       PaymentPlan.MONTHLY: 29900,   # 299.00 RUB
       PaymentPlan.YEARLY: 249900,   # 2499.00 RUB
   }

   # Prices as strings for YooKassa API
   PLAN_PRICES_STR = {
       PaymentPlan.MONTHLY: "299.00",
       PaymentPlan.YEARLY: "2499.00",
   }

   # Subscription duration in days
   PLAN_DURATION_DAYS = {
       PaymentPlan.MONTHLY: 30,
       PaymentPlan.YEARLY: 365,
   }

   TRIAL_DAYS = 3
   ```

3. Create src/services/payment/client.py:
   ```python
   """Async wrapper for YooKassa SDK."""
   import asyncio
   import uuid
   import structlog
   from yookassa import Configuration, Payment as YooPayment

   from src.config import settings

   logger = structlog.get_logger()

   # Configure YooKassa on module load
   def _configure_yookassa():
       if settings.yookassa_shop_id and settings.yookassa_secret_key:
           Configuration.account_id = settings.yookassa_shop_id
           Configuration.secret_key = settings.yookassa_secret_key

   _configure_yookassa()


   async def create_payment(
       user_id: int,
       amount: str,
       description: str,
       save_payment_method: bool = False,
       metadata: dict | None = None,
   ) -> dict:
       """
       Create payment with redirect confirmation.

       Args:
           user_id: Telegram user ID for metadata
           amount: Amount as string (e.g., "299.00")
           description: Payment description
           save_payment_method: Whether to save card for recurring
           metadata: Additional metadata

       Returns:
           YooKassa Payment object as dict
       """
       idempotency_key = str(uuid.uuid4())

       payment_data = {
           "amount": {"value": amount, "currency": "RUB"},
           "confirmation": {
               "type": "redirect",
               "return_url": settings.yookassa_return_url,
           },
           "capture": True,
           "save_payment_method": save_payment_method,
           "description": description,
           "metadata": {
               "user_id": str(user_id),
               **(metadata or {}),
           },
       }

       def _create():
           return YooPayment.create(payment_data, idempotency_key)

       await logger.ainfo(
           "Creating payment",
           user_id=user_id,
           amount=amount,
           save_method=save_payment_method,
       )

       result = await asyncio.to_thread(_create)
       return result


   async def create_recurring_payment(
       payment_method_id: str,
       user_id: int,
       subscription_id: int,
       amount: str,
       description: str,
   ) -> dict:
       """
       Create recurring payment using saved payment method.

       Args:
           payment_method_id: Saved payment method ID
           user_id: User ID
           subscription_id: Subscription ID
           amount: Amount as string
           description: Payment description

       Returns:
           YooKassa Payment object as dict
       """
       idempotency_key = str(uuid.uuid4())

       payment_data = {
           "amount": {"value": amount, "currency": "RUB"},
           "capture": True,
           "payment_method_id": payment_method_id,
           "description": description,
           "metadata": {
               "user_id": str(user_id),
               "subscription_id": str(subscription_id),
               "type": "recurring",
           },
       }

       def _create():
           return YooPayment.create(payment_data, idempotency_key)

       await logger.ainfo(
           "Creating recurring payment",
           user_id=user_id,
           subscription_id=subscription_id,
           amount=amount,
       )

       result = await asyncio.to_thread(_create)
       return result


   async def cancel_recurring(payment_method_id: str) -> bool:
       """
       Cancel recurring payments by invalidating payment method.

       Note: YooKassa doesn't have explicit cancel - we just stop using
       the payment_method_id and clear it from our DB.

       Returns:
           True (always succeeds - we just stop using it)
       """
       await logger.ainfo("Recurring cancelled", payment_method_id=payment_method_id[:8])
       return True
   ```
  </action>
  <verify>
    poetry run python -c "from src.services.payment import create_payment, PLAN_PRICES; print('Client OK')"
    poetry run ruff check src/services/payment/
  </verify>
  <done>
    - schemas.py has PaymentPlan enum, PLAN_PRICES, PLAN_DURATION_DAYS, TRIAL_DAYS
    - client.py has create_payment, create_recurring_payment, cancel_recurring
    - All functions use asyncio.to_thread for sync SDK
    - Idempotency key generated for each payment
    - Logging with structlog
  </done>
</task>

<task type="auto">
  <name>Task 2: Subscription Service + Webhook</name>
  <files>
    src/services/payment/service.py
    src/main.py
  </files>
  <action>
1. Create src/services/payment/service.py:
   ```python
   """Subscription business logic."""
   from datetime import datetime, timedelta, timezone
   from ipaddress import ip_address, ip_network

   import structlog
   from sqlalchemy import select
   from sqlalchemy.ext.asyncio import AsyncSession

   from src.db.models.payment import Payment
   from src.db.models.subscription import Subscription, SubscriptionStatus
   from src.db.models.user import User
   from src.services.payment.schemas import PLAN_DURATION_DAYS, PaymentPlan

   logger = structlog.get_logger()

   # YooKassa IP whitelist
   YOOKASSA_IPS = [
       ip_network("185.71.76.0/27"),
       ip_network("185.71.77.0/27"),
       ip_network("77.75.153.0/25"),
       ip_network("77.75.154.128/25"),
       ip_network("2a02:5180::/32"),
   ]


   def is_yookassa_ip(ip_str: str) -> bool:
       """Check if IP is from YooKassa allowed ranges."""
       try:
           ip = ip_address(ip_str)
           for allowed in YOOKASSA_IPS:
               if ip in allowed:
                   return True
           return False
       except ValueError:
           return False


   async def get_user_subscription(
       session: AsyncSession, user_id: int
   ) -> Subscription | None:
       """Get active subscription for user (by telegram_id)."""
       # First get user by telegram_id
       stmt = select(User).where(User.telegram_id == user_id)
       result = await session.execute(stmt)
       user = result.scalar_one_or_none()

       if not user:
           return None

       # Then get active subscription
       stmt = select(Subscription).where(
           Subscription.user_id == user.id,
           Subscription.status.in_([
               SubscriptionStatus.TRIAL.value,
               SubscriptionStatus.ACTIVE.value,
               SubscriptionStatus.CANCELED.value,  # Still has access until end
           ]),
       )
       result = await session.execute(stmt)
       return result.scalar_one_or_none()


   async def activate_subscription(
       session: AsyncSession,
       user_telegram_id: int,
       plan: PaymentPlan,
       payment_method_id: str | None = None,
       is_trial: bool = False,
   ) -> Subscription:
       """
       Create or activate subscription for user.

       Args:
           session: DB session
           user_telegram_id: Telegram user ID
           plan: Subscription plan
           payment_method_id: Saved payment method for recurring
           is_trial: Whether this is a trial activation

       Returns:
           Created/updated Subscription
       """
       # Get user
       stmt = select(User).where(User.telegram_id == user_telegram_id)
       result = await session.execute(stmt)
       user = result.scalar_one_or_none()

       if not user:
           raise ValueError(f"User not found: {user_telegram_id}")

       now = datetime.now(timezone.utc)
       duration = timedelta(days=PLAN_DURATION_DAYS[plan])

       # Check for existing subscription
       existing = await get_user_subscription(session, user_telegram_id)

       if existing:
           # Extend existing subscription
           existing.current_period_end = existing.current_period_end + duration
           existing.status = SubscriptionStatus.ACTIVE.value
           if payment_method_id:
               existing.payment_method_id = payment_method_id
           subscription = existing
       else:
           # Create new subscription
           subscription = Subscription(
               user_id=user.id,
               plan=plan.value,
               status=SubscriptionStatus.TRIAL.value if is_trial else SubscriptionStatus.ACTIVE.value,
               payment_method_id=payment_method_id,
               started_at=now,
               current_period_start=now,
               current_period_end=now + duration,
               trial_end=now + timedelta(days=3) if is_trial else None,
           )
           session.add(subscription)

       # Update user premium status
       user.is_premium = True
       user.premium_until = subscription.current_period_end
       user.daily_spread_limit = 20  # Premium limit

       await session.commit()

       await logger.ainfo(
           "Subscription activated",
           user_id=user_telegram_id,
           plan=plan.value,
           until=subscription.current_period_end.isoformat(),
       )

       return subscription


   async def cancel_subscription(
       session: AsyncSession,
       user_telegram_id: int,
   ) -> Subscription | None:
       """
       Cancel subscription (access remains until period end).

       Returns:
           Updated Subscription or None if not found
       """
       subscription = await get_user_subscription(session, user_telegram_id)

       if not subscription:
           return None

       subscription.status = SubscriptionStatus.CANCELED.value
       subscription.canceled_at = datetime.now(timezone.utc)
       # Note: user keeps access until premium_until

       await session.commit()

       await logger.ainfo(
           "Subscription canceled",
           user_id=user_telegram_id,
           access_until=subscription.current_period_end.isoformat(),
       )

       return subscription


   async def process_webhook_event(
       session: AsyncSession,
       event: dict,
   ) -> bool:
       """
       Process YooKassa webhook event idempotently.

       Args:
           session: DB session
           event: Webhook event payload

       Returns:
           True if processed, False if duplicate
       """
       event_type = event.get("event")
       payment_data = event.get("object", {})
       payment_id = payment_data.get("id")

       if not payment_id:
           await logger.awarning("Webhook missing payment_id", event=event)
           return False

       # Check idempotency - already processed?
       existing = await session.get(Payment, payment_id)
       if existing and existing.webhook_processed:
           await logger.ainfo("Webhook duplicate, skipping", payment_id=payment_id)
           return False

       metadata = payment_data.get("metadata", {})
       user_id = metadata.get("user_id")
       plan_type = metadata.get("plan_type")

       await logger.ainfo(
           "Processing webhook",
           event_type=event_type,
           payment_id=payment_id,
           user_id=user_id,
       )

       if event_type == "payment.succeeded":
           status = payment_data.get("status")
           amount_value = payment_data.get("amount", {}).get("value", "0")
           amount_kopeks = int(float(amount_value) * 100)
           payment_method = payment_data.get("payment_method", {})
           payment_method_id = payment_method.get("id") if payment_method.get("saved") else None

           # Create or update payment record
           if existing:
               existing.status = status
               existing.webhook_processed = True
               existing.paid_at = datetime.now(timezone.utc)
               payment = existing
           else:
               payment = Payment(
                   id=payment_id,
                   user_id=int(user_id) if user_id else 0,  # Will be updated
                   amount=amount_kopeks,
                   status=status,
                   description=payment_data.get("description"),
                   is_recurring=metadata.get("type") == "recurring",
                   webhook_processed=True,
                   paid_at=datetime.now(timezone.utc),
               )
               session.add(payment)

           # Activate subscription if this is a subscription payment
           if user_id and plan_type:
               plan = PaymentPlan(plan_type)
               await activate_subscription(
                   session,
                   int(user_id),
                   plan,
                   payment_method_id=payment_method_id,
               )

           await session.commit()
           return True

       elif event_type == "payment.canceled":
           if existing:
               existing.status = "canceled"
               existing.webhook_processed = True
               await session.commit()
           return True

       return False
   ```

2. Update src/main.py - add webhook endpoint after telegram webhook:
   ```python
   # Add imports at top:
   from fastapi import BackgroundTasks

   from src.services.payment.service import is_yookassa_ip, process_webhook_event
   from src.db.engine import async_session_maker

   # Add after /webhook endpoint (before lifespan if any):

   @app.post("/webhook/yookassa")
   async def yookassa_webhook(
       request: Request,
       background_tasks: BackgroundTasks,
   ) -> Response:
       """
       Handle YooKassa webhook notifications.

       Returns 200 immediately, processes in background.
       """
       # IP verification
       client_ip = request.client.host if request.client else ""

       # In production, verify IP (skip in dev)
       if settings.railway_environment and not is_yookassa_ip(client_ip):
           await logger.awarning("YooKassa webhook from unknown IP", ip=client_ip)
           # Still return 200 to not reveal we're rejecting
           return Response(status_code=200)

       try:
           event = await request.json()
       except Exception:
           return Response(status_code=200)

       # Process in background
       async def process_event():
           async with async_session_maker() as session:
               await process_webhook_event(session, event)

       background_tasks.add_task(process_event)

       # Return 200 immediately
       return Response(status_code=200)
   ```

3. Add async_session_maker to src/db/engine.py if not exists:
   ```python
   from sqlalchemy.ext.asyncio import async_sessionmaker

   async_session_maker = async_sessionmaker(engine, expire_on_commit=False)
   ```
  </action>
  <verify>
    poetry run python -c "from src.services.payment import activate_subscription, process_webhook_event; print('Service OK')"
    poetry run python -c "from src.main import app; print([r.path for r in app.routes])"
    # Should include /webhook/yookassa
    poetry run ruff check src/
  </verify>
  <done>
    - service.py has activate_subscription, cancel_subscription, process_webhook_event, get_user_subscription
    - IP whitelist verification for YooKassa
    - Webhook returns 200 immediately, processes in BackgroundTasks
    - Idempotency via webhook_processed flag
    - Payment record created with YooKassa payment_id as PK
    - User.is_premium and User.premium_until updated on activation
  </done>
</task>

</tasks>

<verification>
1. `poetry run python -c "from src.services.payment import create_payment, activate_subscription; print('OK')"`
2. `poetry run python -c "from src.main import app; routes = [r.path for r in app.routes]; assert '/webhook/yookassa' in routes; print('Webhook route OK')"`
3. `curl -X POST http://localhost:8000/webhook/yookassa -H "Content-Type: application/json" -d '{}'` returns 200
4. `poetry run ruff check src/` passes
</verification>

<success_criteria>
- YooKassa client uses asyncio.to_thread for all SDK calls
- create_payment saves payment method for recurring
- Webhook endpoint at /webhook/yookassa returns 200 immediately
- Webhook processing is idempotent (duplicate events ignored)
- Subscription activated on payment.succeeded
- User.is_premium, premium_until, daily_spread_limit updated
- IP whitelist verification for webhook in production
- ruff check passes
</success_criteria>

<output>
After completion, create `.planning/phases/06-payments/06-02-SUMMARY.md`
</output>
