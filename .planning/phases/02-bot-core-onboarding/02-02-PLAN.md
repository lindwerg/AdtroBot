---
phase: 02-bot-core-onboarding
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/bot/states/__init__.py
  - src/bot/states/onboarding.py
  - src/bot/keyboards/__init__.py
  - src/bot/keyboards/main_menu.py
  - src/bot/utils/__init__.py
  - src/bot/utils/zodiac.py
  - src/bot/utils/date_parser.py
  - src/bot/utils/horoscope.py
  - src/bot/handlers/__init__.py
  - src/bot/handlers/start.py
  - src/bot/handlers/menu.py
  - src/bot/handlers/common.py
  - src/bot/bot.py
autonomous: true

must_haves:
  truths:
    - "Пользователь нажимает /start и видит приветствие"
    - "Новый пользователь видит кнопку 'Получить первый прогноз'"
    - "Returning user сразу видит главное меню"
    - "Бот запрашивает дату рождения после нажатия кнопки"
    - "Пользователь может ввести дату в любом формате и видит подтверждение знака"
    - "Пользователь видит свой знак зодиака после ввода даты"
    - "Пользователь получает mock-прогноз сразу после регистрации"
    - "Главное меню показывает 4 кнопки в сетке 2x2"
    - "Данные пользователя сохраняются и доступны при повторном визите"
  artifacts:
    - path: "src/bot/handlers/start.py"
      provides: "/start command and onboarding flow"
      exports: ["router"]
    - path: "src/bot/states/onboarding.py"
      provides: "FSM states for onboarding"
      exports: ["OnboardingStates"]
    - path: "src/bot/keyboards/main_menu.py"
      provides: "Reply keyboards"
      exports: ["get_main_menu_keyboard", "get_start_keyboard"]
    - path: "src/bot/utils/zodiac.py"
      provides: "Zodiac calculation"
      exports: ["get_zodiac_sign", "ZodiacSign"]
    - path: "src/bot/utils/date_parser.py"
      provides: "Russian date parsing"
      exports: ["parse_russian_date"]
  key_links:
    - from: "src/bot/handlers/start.py"
      to: "src/db/models/user.py"
      via: "SQLAlchemy queries"
      pattern: "select\\(User\\)"
    - from: "src/bot/handlers/start.py"
      to: "src/bot/utils/zodiac.py"
      via: "get_zodiac_sign import"
      pattern: "from src.bot.utils.zodiac import"
    - from: "src/bot/handlers/start.py"
      to: "src/bot/utils/date_parser.py"
      via: "parse_russian_date import"
      pattern: "from src.bot.utils.date_parser import"
    - from: "src/bot/bot.py"
      to: "src/bot/handlers/"
      via: "dp.include_routers"
      pattern: "dp.include_router"
---

<objective>
Complete onboarding flow: /start command, birthdate collection via FSM, zodiac determination, immediate value (mock-прогноз), main menu.

Purpose: User can register, get first forecast (mock), and see main menu with navigation.
Output: Working /start -> birthdate -> zodiac -> mock-прогноз -> menu flow.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-bot-core-onboarding/02-RESEARCH.md
@.planning/phases/02-bot-core-onboarding/02-01-SUMMARY.md
@.planning/phases/02-bot-core-onboarding/02-CONTEXT.md
@src/bot/bot.py
@src/db/models/user.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: FSM States + Keyboards + Utils</name>
  <files>
    src/bot/states/__init__.py
    src/bot/states/onboarding.py
    src/bot/keyboards/__init__.py
    src/bot/keyboards/main_menu.py
    src/bot/utils/__init__.py
    src/bot/utils/zodiac.py
    src/bot/utils/date_parser.py
    src/bot/utils/horoscope.py
  </files>
  <action>
    1. Create src/bot/states/__init__.py:
       ```python
       from src.bot.states.onboarding import OnboardingStates
       __all__ = ["OnboardingStates"]
       ```

    2. Create src/bot/states/onboarding.py:
       ```python
       from aiogram.fsm.state import State, StatesGroup

       class OnboardingStates(StatesGroup):
           waiting_birthdate = State()
       ```

    3. Create src/bot/keyboards/__init__.py:
       ```python
       from src.bot.keyboards.main_menu import get_main_menu_keyboard, get_start_keyboard
       __all__ = ["get_main_menu_keyboard", "get_start_keyboard"]
       ```

    4. Create src/bot/keyboards/main_menu.py:
       - get_main_menu_keyboard(): ReplyKeyboardMarkup 2x2 grid with buttons:
         Row 1: "Гороскоп", "Таро"
         Row 2: "Подписка", "Профиль"
         Use ReplyKeyboardBuilder, builder.adjust(2), resize_keyboard=True
       - get_start_keyboard(): InlineKeyboardMarkup with single button:
         "Получить первый прогноз" -> callback_data="get_first_forecast"

    5. Create src/bot/utils/__init__.py:
       ```python
       from src.bot.utils.zodiac import get_zodiac_sign, ZodiacSign
       from src.bot.utils.date_parser import parse_russian_date
       from src.bot.utils.horoscope import get_mock_horoscope
       __all__ = ["get_zodiac_sign", "ZodiacSign", "parse_russian_date", "get_mock_horoscope"]
       ```

    6. Create src/bot/utils/zodiac.py:
       - ZodiacSign dataclass with: name (English), name_ru, emoji
       - ZODIAC_SIGNS list (12 signs with emoji: Овен, Телец, Близнецы, Рак, Лев, Дева, Весы, Скорпион, Стрелец, Козерог, Водолей, Рыбы)
       - ZODIAC_DATES: boundaries for each sign (month, day)
       - get_zodiac_sign(birth_date: date) -> ZodiacSign: returns zodiac based on date

       Zodiac boundaries (inclusive start):
       - Козерог: Dec 22 - Jan 19
       - Водолей: Jan 20 - Feb 18
       - Рыбы: Feb 19 - Mar 20
       - Овен: Mar 21 - Apr 19
       - Телец: Apr 20 - May 20
       - Близнецы: May 21 - Jun 20
       - Рак: Jun 21 - Jul 22
       - Лев: Jul 23 - Aug 22
       - Дева: Aug 23 - Sep 22
       - Весы: Sep 23 - Oct 22
       - Скорпион: Oct 23 - Nov 21
       - Стрелец: Nov 22 - Dec 21

    7. Create src/bot/utils/date_parser.py:
       - parse_russian_date(text: str) -> date | None
       - Use dateparser.parse with languages=['ru'], settings={'DATE_ORDER': 'DMY'}
       - Validate year range: 1920 <= year <= current_year - 5
       - Return date() object, not datetime

    8. Create src/bot/utils/horoscope.py:
       - MOCK_HOROSCOPES: dict[str, str] - 12 mock horoscope texts keyed by zodiac name (English)
       - get_mock_horoscope(zodiac_name: str) -> str: returns mock horoscope text
       - Texts should be ~3-4 sentences, generic but interesting, in Russian
       - Include emoji at start (same as zodiac emoji)
  </action>
  <verify>
    ```bash
    python -c "from src.bot.states import OnboardingStates; print(OnboardingStates.waiting_birthdate)"
    python -c "from src.bot.keyboards import get_main_menu_keyboard; print(get_main_menu_keyboard())"
    python -c "from src.bot.utils import get_zodiac_sign; from datetime import date; print(get_zodiac_sign(date(1990, 3, 15)))"
    python -c "from src.bot.utils import parse_russian_date; print(parse_russian_date('15 марта 1990'))"
    python -c "from src.bot.utils import get_mock_horoscope; print(get_mock_horoscope('Pisces')[:50])"
    ```
  </verify>
  <done>
    OnboardingStates.waiting_birthdate exists.
    get_main_menu_keyboard returns 2x2 reply keyboard.
    get_start_keyboard returns inline keyboard with "Получить первый прогноз".
    get_zodiac_sign correctly determines zodiac from date.
    parse_russian_date parses Russian dates.
    get_mock_horoscope returns Russian horoscope text.
  </done>
</task>

<task type="auto">
  <name>Task 2: Handlers + Router Registration</name>
  <files>
    src/bot/handlers/__init__.py
    src/bot/handlers/start.py
    src/bot/handlers/menu.py
    src/bot/handlers/common.py
    src/bot/bot.py
  </files>
  <action>
    1. Create src/bot/handlers/__init__.py:
       ```python
       from src.bot.handlers.start import router as start_router
       from src.bot.handlers.menu import router as menu_router
       from src.bot.handlers.common import router as common_router
       __all__ = ["start_router", "menu_router", "common_router"]
       ```

    2. Create src/bot/handlers/start.py (main onboarding logic):
       - Router with name="start"
       - /start command handler:
         - Query User by telegram_id
         - If user exists AND has birth_date: show main menu directly (no greeting)
         - If new user or no birth_date: show welcome message + get_start_keyboard
         - Welcome message (from CONTEXT.md):
           "Привет! Я астробот - твой персональный проводник в мир астрологии и таро.

           Что я умею:
           - Ежедневные гороскопы для твоего знака
           - Расклады таро с AI-интерпретацией
           - Персональные прогнозы

           Базовые функции бесплатны. Подписка открывает детальные гороскопы по сферам жизни и расширенные расклады."
       - "get_first_forecast" callback handler:
         - Send message: "Введи дату рождения (например, 15.03.1990 или 15 марта 1990):"
         - Set state to OnboardingStates.waiting_birthdate
       - waiting_birthdate message handler:
         - Parse date with parse_russian_date
         - If parse fails: "Неверный формат. Попробуй ещё раз"
         - If success:
           - Get zodiac with get_zodiac_sign
           - Get or create User (upsert pattern)
           - Update birth_date and zodiac_sign on User object
           - **CRITICAL: await session.commit()** - DbSessionMiddleware does NOT auto-commit
           - Clear FSM state
           - Send: f"Твой знак: {zodiac.emoji} {zodiac.name_ru}"
           - Send mock horoscope with get_mock_horoscope
           - Send teaser: "Хочешь карту дня? Нажми 'Таро'" with main menu keyboard

       Handler signatures must include session: AsyncSession parameter (injected by middleware).

    3. Create src/bot/handlers/menu.py:
       - Router with name="menu"
       - Text message handlers for menu buttons (use F.text filter):
         - "Гороскоп":
           - If user has zodiac_sign: show mock horoscope for their sign
           - If no zodiac_sign: prompt to complete registration
         - "Таро": Send teaser "Расклады таро скоро будут доступны! Следи за обновлениями."
         - "Подписка": Send teaser "Подписка откроет доступ к детальным гороскопам и расширенным раскладам. Скоро!"
         - "Профиль": Show user info (telegram_id, zodiac_sign if set, birth_date if set)

    4. Create src/bot/handlers/common.py:
       - Router with name="common"
       - Catch-all handler for unknown messages (lowest priority):
         - Send: "Не понимаю. Используй меню или команду /start"
         - Show main menu keyboard

    5. Update src/bot/bot.py:
       - Import routers from src.bot.handlers
       - Include all routers: dp.include_routers(start_router, menu_router, common_router)
       - Order matters: start_router first, then menu_router, then common_router (catch-all last)
  </action>
  <verify>
    ```bash
    # Check routers import
    python -c "from src.bot.handlers import start_router, menu_router, common_router; print('Routers imported')"
    python -c "from src.bot.bot import dp; print('Routers:', [r.name for r in dp.sub_routers])"
    grep -q "include_router" src/bot/bot.py && echo "Routers included in dispatcher"

    # Check onboarding logic components
    python -c "
from src.bot.utils.date_parser import parse_russian_date
from src.bot.utils.zodiac import get_zodiac_sign
from src.bot.utils.horoscope import get_mock_horoscope
from datetime import date

# Test date parsing formats
assert parse_russian_date('15.03.1990') == date(1990, 3, 15), 'DD.MM.YYYY failed'
assert parse_russian_date('15/03/1990') == date(1990, 3, 15), 'DD/MM/YYYY failed'
assert parse_russian_date('15 марта 1990') == date(1990, 3, 15), 'Russian text failed'
print('Date parsing: OK')

# Test zodiac determination
z = get_zodiac_sign(date(1990, 3, 15))
assert z.name == 'Pisces', f'Expected Pisces, got {z.name}'
assert z.name_ru == 'Рыбы', f'Expected Рыбы, got {z.name_ru}'
print('Zodiac detection: OK')

# Test mock horoscope
h = get_mock_horoscope('Pisces')
assert len(h) > 50, 'Horoscope too short'
print('Mock horoscope: OK')
"

    # Check FSM state exists
    python -c "from src.bot.states.onboarding import OnboardingStates; print('FSM state:', OnboardingStates.waiting_birthdate)"

    # Check session.commit is in handler
    grep -q "session.commit" src/bot/handlers/start.py && echo "session.commit found in handler"
    ```
  </verify>
  <done>
    /start shows welcome for new users, menu for returning users.
    Birthdate collection works with FSM.
    Date parsing handles multiple formats (DD.MM.YYYY, DD/MM/YYYY, Russian text).
    Zodiac determined correctly and saved to DB.
    session.commit() explicitly called after User update.
    Mock horoscope shown after registration.
    Menu buttons respond with content or teasers.
    Unknown messages handled gracefully.
    All routers registered in dispatcher.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integration Test</name>
  <files>
    (no new files - testing existing)
  </files>
  <action>
    Verify complete flow works:

    1. Import test:
       ```bash
       poetry run python -c "
       from src.main import app
       from src.bot.bot import bot, dp
       from src.bot.handlers import start_router, menu_router, common_router
       print('All imports OK')
       print(f'Bot token configured: {bool(bot.token)}')
       print(f'Routers: {[r.name for r in dp.sub_routers]}')
       "
       ```

    2. Utility test:
       ```bash
       poetry run python -c "
       from datetime import date
       from src.bot.utils import get_zodiac_sign, parse_russian_date, get_mock_horoscope

       # Test zodiac
       d = date(1990, 3, 15)
       z = get_zodiac_sign(d)
       assert z.name == 'Pisces', f'Expected Pisces, got {z.name}'
       print(f'March 15 -> {z.emoji} {z.name_ru}')

       # Test date parsing
       parsed = parse_russian_date('15 марта 1990')
       assert parsed == d, f'Expected {d}, got {parsed}'
       print(f'Parsed: {parsed}')

       # Test mock horoscope
       h = get_mock_horoscope('Pisces')
       assert len(h) > 50
       print(f'Horoscope preview: {h[:60]}...')

       print('All utility tests passed!')
       "
       ```

    3. Keyboard test:
       ```bash
       poetry run python -c "
       from src.bot.keyboards import get_main_menu_keyboard, get_start_keyboard

       menu = get_main_menu_keyboard()
       print(f'Main menu buttons: {[[btn.text for btn in row] for row in menu.keyboard]}')

       start = get_start_keyboard()
       print(f'Start keyboard: {[[btn.text for btn in row] for row in start.inline_keyboard]}')
       "
       ```

    If any test fails, fix the issue before marking complete.
  </action>
  <verify>
    All three test commands pass without errors.
  </verify>
  <done>
    All imports work.
    Zodiac calculation correct for edge cases.
    Date parsing handles Russian format.
    Mock horoscopes return content.
    Keyboards have correct structure.
  </done>
</task>

</tasks>

<verification>
Phase 2 complete when:
1. `/start` command works (new user sees welcome, returning user sees menu)
2. Birthdate collection parses multiple formats
3. Zodiac correctly determined and saved
4. Mock-прогноз shown after registration (immediate value)
5. Main menu 2x2 with working button handlers
6. All code imports without errors
</verification>

<success_criteria>
- /start shows welcome message to new users
- /start shows menu directly to returning users
- "Получить первый прогноз" button starts onboarding
- Birthdate parsed from Russian text (DD.MM.YYYY, DD/MM/YYYY, "15 марта 1990")
- Zodiac sign correctly determined from date
- User.birth_date and User.zodiac_sign saved to DB (with explicit session.commit())
- **Mock-прогноз shown immediately after registration (immediate value fulfilled via hardcoded horoscope texts)**
- Main menu has 4 buttons: Гороскоп, Таро, Подписка, Профиль
- Menu buttons respond (mock horoscope for registered, teasers for others)
- Unknown messages handled gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/02-bot-core-onboarding/02-02-SUMMARY.md`
</output>
