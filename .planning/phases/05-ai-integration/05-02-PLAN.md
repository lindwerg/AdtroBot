---
phase: 05-ai-integration
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/bot/utils/horoscope.py
  - src/bot/handlers/horoscope.py
  - src/bot/handlers/tarot.py
  - src/bot/utils/tarot_formatting.py
autonomous: true

must_haves:
  truths:
    - "Horoscope button shows AI-generated text with 4 sections"
    - "Card of day shows AI interpretation instead of static meaning"
    - "3-card spread shows AI interpretation based on question and cards"
    - "Fallback message shown when AI unavailable"
    - "Zodiac navigation still works with AI horoscopes"
  artifacts:
    - path: "src/bot/utils/horoscope.py"
      provides: "get_horoscope_text() async function using AI"
    - path: "src/bot/handlers/horoscope.py"
      provides: "Updated handlers using async AI horoscopes"
    - path: "src/bot/handlers/tarot.py"
      provides: "AI interpretation for card of day and 3-card spread"
    - path: "src/bot/utils/tarot_formatting.py"
      provides: "format_ai_interpretation() for AI text display"
  key_links:
    - from: "src/bot/utils/horoscope.py"
      to: "src/services/ai/client.py"
      via: "get_ai_service().generate_horoscope()"
      pattern: "get_ai_service\\(\\)"
    - from: "src/bot/handlers/tarot.py"
      to: "src/services/ai/client.py"
      via: "get_ai_service().generate_card_of_day()"
      pattern: "generate_card_of_day"
    - from: "src/bot/handlers/tarot.py"
      to: "src/services/ai/client.py"
      via: "get_ai_service().generate_tarot_interpretation()"
      pattern: "generate_tarot_interpretation"
---

<objective>
Integrate AI service into horoscope and tarot handlers.

Purpose: Replace mock horoscopes with AI-generated content. Add AI interpretations to tarot card of day and 3-card spreads. Implement graceful fallback when AI unavailable.

Output: Working AI-powered horoscope and tarot features with fallback handling.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-ai-integration/05-01-SUMMARY.md
@src/bot/utils/horoscope.py
@src/bot/handlers/horoscope.py
@src/bot/handlers/tarot.py
@src/bot/utils/tarot_formatting.py
@src/bot/utils/zodiac.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Horoscope AI Integration</name>
  <files>
    - src/bot/utils/horoscope.py
    - src/bot/handlers/horoscope.py
  </files>
  <action>
**1. Update src/bot/utils/horoscope.py:**

Keep MOCK_HOROSCOPES dict as fallback reference. Add new async function:

```python
from datetime import date
from src.services.ai import get_ai_service

FALLBACK_MESSAGE = (
    "Сервис временно недоступен. Пожалуйста, попробуй через несколько минут.\n\n"
    "Иногда звезды молчат, чтобы мы прислушались к себе."
)

async def get_horoscope_text(zodiac_name: str, zodiac_name_ru: str) -> str:
    """
    Get horoscope text from AI (with caching) or return fallback.

    Args:
        zodiac_name: English name (e.g., "Aries")
        zodiac_name_ru: Russian name (e.g., "Овен")

    Returns:
        Horoscope text ready for display
    """
    ai = get_ai_service()
    date_str = date.today().strftime("%d.%m.%Y")

    text = await ai.generate_horoscope(zodiac_name, zodiac_name_ru, date_str)

    if text:
        return text

    return FALLBACK_MESSAGE
```

Keep get_mock_horoscope() for backwards compatibility but mark as deprecated comment.

**2. Update src/bot/handlers/horoscope.py:**

The handlers need to become async and use the new get_horoscope_text().

Key changes:
- Remove `_parse_mock_horoscope()` function - AI generates structured text directly
- Update `show_zodiac_horoscope()` callback to call async `get_horoscope_text()`
- Update `show_horoscope_message()` to call async `get_horoscope_text()`
- Update `format_daily_horoscope()` call - AI text is complete, no need to split forecast/tip

For formatting, since AI returns full text with sections, update approach:
- AI text already has [ЛЮБОВЬ], [КАРЬЕРА], etc. sections
- Use simpler formatting: Bold header + Text content
- Or parse AI sections and format with BlockQuote

Simpler approach (recommended): Display AI text as-is with minimal formatting:
```python
from aiogram.utils.formatting import Bold, Text

async def show_zodiac_horoscope(callback, callback_data):
    sign_name = callback_data.s
    zodiac = ZODIAC_SIGNS.get(sign_name)

    if not zodiac:
        await callback.answer("Знак не найден", show_alert=True)
        return

    text = await get_horoscope_text(sign_name, zodiac.name_ru)

    content = Text(
        Bold(f"{zodiac.emoji} Гороскоп для {zodiac.name_ru_genitive}"),
        "\n",
        f"на {date.today().strftime('%d.%m.%Y')}",
        "\n\n",
        text,
    )

    await callback.message.edit_text(
        **content.as_kwargs(),
        reply_markup=build_zodiac_keyboard(current_sign=sign_name),
    )
    await callback.answer()
```

Note: ZODIAC_SIGNS already has `name_ru_genitive` for "для Овна" style (check zodiac.py, add if missing).

If `name_ru_genitive` doesn't exist in ZodiacSign dataclass, use `name_ru` with manual mapping or simpler "Гороскоп: {name_ru}".

Update `show_horoscope_message()` similarly for consistency.
  </action>
  <verify>
    - `ruff check src/bot/utils/horoscope.py src/bot/handlers/horoscope.py` passes
    - `python -c "from src.bot.utils.horoscope import get_horoscope_text"` works
    - `python -c "from src.bot.handlers.horoscope import show_horoscope_message"` works
  </verify>
  <done>Horoscope handlers use AI with fallback to error message</done>
</task>

<task type="auto">
  <name>Task 2: Tarot AI Integration</name>
  <files>
    - src/bot/utils/tarot_formatting.py
    - src/bot/handlers/tarot.py
  </files>
  <action>
**1. Update src/bot/utils/tarot_formatting.py:**

Add function for AI interpretation display:

```python
def format_ai_interpretation(interpretation: str) -> Text:
    """
    Format AI-generated interpretation text.

    AI text comes with [SECTION] headers that need to be displayed nicely.
    """
    return Text(
        Bold("Интерпретация:"),
        "\n\n",
        interpretation,
    )


def format_card_of_day_with_ai(card: dict, reversed_flag: bool, ai_interpretation: str | None) -> Text:
    """
    Format Card of the Day with AI interpretation.

    If AI interpretation available, show it instead of static meaning.
    """
    card_name = card["name"]
    card_type = CARD_TYPE_RU.get(card["type"], card["type"])
    reversed_text = " (перевернутая)" if reversed_flag else ""

    parts = [
        Bold("Карта дня"),
        "\n\n",
        Bold(f"{card_name}{reversed_text}"),
        "\n",
        card_type,
        "\n\n",
    ]

    if ai_interpretation:
        parts.append(ai_interpretation)
    else:
        # Fallback to static meaning
        meaning = card["meaning_rev"] if reversed_flag else card["meaning_up"]
        parts.extend([
            Bold("Значение:"),
            "\n",
            BlockQuote(meaning),
        ])

    return Text(*parts)


def format_three_card_spread_with_ai(
    cards: list[tuple[dict, bool]],
    question: str,
    ai_interpretation: str | None,
) -> Text:
    """
    Format 3-card spread with AI interpretation.

    If AI interpretation available, show question + cards + AI text.
    Otherwise fallback to static meanings.
    """
    content: list = [
        Bold("Ваш вопрос:"),
        "\n",
        BlockQuote(question),
        "\n\n",
    ]

    # Show cards with names
    content.append(Bold("Карты расклада:"))
    content.append("\n")
    for i, (card, reversed_flag) in enumerate(cards):
        position = SPREAD_POSITIONS[i]
        card_name = card["name"]
        reversed_text = " (перевернутая)" if reversed_flag else ""
        content.append(f"{position}: {card_name}{reversed_text}\n")

    content.append("\n")

    if ai_interpretation:
        content.append(ai_interpretation)
    else:
        # Fallback to static meanings (same as original format_three_card_spread)
        for i, (card, reversed_flag) in enumerate(cards):
            position = SPREAD_POSITIONS[i]
            meaning = card["meaning_rev"] if reversed_flag else card["meaning_up"]
            content.extend([
                Bold(f"{position}:"),
                "\n",
                BlockQuote(meaning),
                "\n\n",
            ])

    return Text(*content)


AI_FALLBACK_MESSAGE = "Сервис временно недоступен. Попробуй позже."
```

**2. Update src/bot/handlers/tarot.py:**

Import AI service and update handlers:

```python
from src.services.ai import get_ai_service
from src.bot.utils.tarot_formatting import (
    format_card_of_day_with_ai,
    format_three_card_spread_with_ai,
    format_limit_exceeded,
    format_limit_message,
    AI_FALLBACK_MESSAGE,
)
```

**Update send_card_of_day():**
```python
async def send_card_of_day(message: Message, card: dict, reversed_flag: bool, user_id: int) -> None:
    """Send card of the day with image and AI interpretation."""
    # Send image first
    photo = get_card_image(card["name_short"], reversed_flag)
    await message.answer_photo(photo)

    # Get AI interpretation
    ai = get_ai_service()
    interpretation = await ai.generate_card_of_day(user_id, card, reversed_flag)

    # Send formatted message (AI or fallback)
    content = format_card_of_day_with_ai(card, reversed_flag, interpretation)
    await message.answer(**content.as_kwargs(), reply_markup=get_tarot_menu_keyboard())
```

Update calls to send_card_of_day() to pass user_id (from callback.from_user.id or message.from_user.id).

**Update tarot_draw_three_cards():**
After drawing cards, before sending interpretation:
```python
# Get AI interpretation
ai = get_ai_service()
cards_data = [card for card, _ in cards]
is_reversed_list = [reversed_flag for _, reversed_flag in cards]
interpretation = await ai.generate_tarot_interpretation(question, cards_data, is_reversed_list)

# Send interpretation
content = format_three_card_spread_with_ai(cards, question, interpretation)
```

Key changes summary:
1. `send_card_of_day()` now takes user_id parameter for caching
2. Uses `format_card_of_day_with_ai()` with AI interpretation
3. `tarot_draw_three_cards()` calls `generate_tarot_interpretation()` before formatting
4. Uses `format_three_card_spread_with_ai()` with AI interpretation
5. Both gracefully fallback to static meanings if AI returns None
  </action>
  <verify>
    - `ruff check src/bot/utils/tarot_formatting.py src/bot/handlers/tarot.py` passes
    - `python -c "from src.bot.utils.tarot_formatting import format_card_of_day_with_ai, format_three_card_spread_with_ai"` works
    - `python -c "from src.bot.handlers.tarot import send_card_of_day"` works
  </verify>
  <done>Tarot handlers use AI interpretations with fallback to static meanings</done>
</task>

</tasks>

<verification>
After both tasks:
1. `ruff check src/bot/` passes
2. All handler imports work
3. Code is ready for testing with real OPENROUTER_API_KEY
</verification>

<success_criteria>
- [ ] Horoscope handlers call AIService.generate_horoscope()
- [ ] Horoscope shows fallback message when AI fails
- [ ] Card of day uses AI interpretation (with static fallback)
- [ ] 3-card spread uses AI interpretation (with static fallback)
- [ ] All existing functionality preserved (zodiac keyboard, limits, etc.)
- [ ] Code passes ruff check
</success_criteria>

<output>
After completion, create `.planning/phases/05-ai-integration/05-02-SUMMARY.md`
</output>
