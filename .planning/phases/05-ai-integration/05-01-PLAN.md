---
phase: 05-ai-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/config.py
  - src/services/ai/__init__.py
  - src/services/ai/client.py
  - src/services/ai/prompts.py
  - src/services/ai/validators.py
  - src/services/ai/cache.py
autonomous: true
user_setup:
  - service: openrouter
    why: "AI generation via OpenRouter API"
    env_vars:
      - name: OPENROUTER_API_KEY
        source: "https://openrouter.ai/settings/keys -> Create New Key"

must_haves:
  truths:
    - "AIService can generate horoscope text via OpenRouter"
    - "AIService can generate tarot interpretation via OpenRouter"
    - "AIService can generate card of day interpretation via OpenRouter"
    - "Responses are validated for length and structure"
    - "Horoscopes are cached for the day"
  artifacts:
    - path: "src/services/ai/__init__.py"
      provides: "Module exports"
    - path: "src/services/ai/client.py"
      provides: "AIService class with generate_horoscope, generate_tarot_interpretation, generate_card_of_day"
      exports: ["AIService", "get_ai_service"]
    - path: "src/services/ai/prompts.py"
      provides: "Prompt templates for horoscope, tarot spread, card of day"
      exports: ["HoroscopePrompt", "TarotSpreadPrompt", "CardOfDayPrompt"]
    - path: "src/services/ai/validators.py"
      provides: "Pydantic validation for AI outputs"
      exports: ["validate_horoscope", "validate_tarot", "validate_card_of_day"]
    - path: "src/services/ai/cache.py"
      provides: "Simple TTL cache for horoscopes and card of day"
      exports: ["get_cached_horoscope", "set_cached_horoscope", "get_cached_card_of_day", "set_cached_card_of_day"]
  key_links:
    - from: "src/services/ai/client.py"
      to: "openrouter.ai/api/v1"
      via: "AsyncOpenAI with base_url"
      pattern: "base_url.*openrouter"
    - from: "src/services/ai/client.py"
      to: "src/services/ai/prompts.py"
      via: "import prompts"
      pattern: "from src.services.ai.prompts import"
    - from: "src/services/ai/client.py"
      to: "src/services/ai/validators.py"
      via: "import validators"
      pattern: "from src.services.ai.validators import"
    - from: "src/services/ai/client.py"
      to: "src/services/ai/cache.py"
      via: "import cache functions"
      pattern: "from src.services.ai.cache import"
---

<objective>
Create the AI service layer for OpenRouter/GPT-4o-mini integration.

Purpose: Foundation for AI-powered horoscope and tarot interpretations. Isolates API specifics, prompt engineering, validation, and caching from handler logic.

Output: Complete `src/services/ai/` module ready for handler integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-ai-integration/05-CONTEXT.md
@.planning/phases/05-ai-integration/05-RESEARCH.md
@src/config.py
@src/services/scheduler.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Dependencies + Config</name>
  <files>
    - pyproject.toml
    - src/config.py
  </files>
  <action>
1. Add dependencies to pyproject.toml:
   ```
   "openai (>=1.50.0,<2.0.0)",
   "tenacity (>=8.2.0,<9.0.0)",
   ```

2. Add OPENROUTER_API_KEY to src/config.py Settings class:
   ```python
   # OpenRouter
   openrouter_api_key: str = Field(
       default="",
       validation_alias="OPENROUTER_API_KEY",
   )
   ```

3. Run `poetry lock && poetry install` to install dependencies.
  </action>
  <verify>
    - `poetry show openai` shows version >= 1.50.0
    - `poetry show tenacity` shows version >= 8.2.0
    - `python -c "from src.config import settings; print(settings.openrouter_api_key)"` runs without error
  </verify>
  <done>openai and tenacity installed, OPENROUTER_API_KEY in config</done>
</task>

<task type="auto">
  <name>Task 2: AI Service Module</name>
  <files>
    - src/services/ai/__init__.py
    - src/services/ai/prompts.py
    - src/services/ai/validators.py
    - src/services/ai/cache.py
    - src/services/ai/client.py
  </files>
  <action>
Create `src/services/ai/` directory with 5 files:

**1. src/services/ai/__init__.py:**
```python
from src.services.ai.client import AIService, get_ai_service

__all__ = ["AIService", "get_ai_service"]
```

**2. src/services/ai/prompts.py:**
Create dataclasses with SYSTEM prompts and user() methods for:
- HoroscopePrompt: SYSTEM prompt for daily horoscope generation (love/career/health/finance sections, friendly "ty" tone, Barnum effect details, 300-500 words). user() takes zodiac_sign_ru, date_str.
- TarotSpreadPrompt: SYSTEM for 3-card spread interpretation (past/present/future, question integration NOT quote, 300-500 words). user() takes question (sanitized 500 chars max, no newlines), cards list, is_reversed list.
- CardOfDayPrompt: SYSTEM for card of day (meaning/message/advice, inspiring tone, 150-250 words). user() takes card dict, is_reversed bool.

Use Russian text for all prompts. Include instructions:
- Обращайся на "ты", дружелюбно и тепло
- НЕ упоминай, что ты AI
- Use zodiac-specific greeting for horoscopes ("Дорогой Овен" / "Дорогая Дева" based on gender)

**3. src/services/ai/validators.py:**
Create Pydantic models with @field_validator:
- HoroscopeOutput: text field, validate length 800-4000 chars, check for 3+ of 4 keywords (любовь/карьер/здоровь/финанс), filter AI self-references
- TarotOutput: text field, validate length 500-4000 chars, check for 2+ position references (прошл/настоящ/будущ)
- CardOfDayOutput: text field, validate length 300-2000 chars

Create wrapper functions that return (is_valid: bool, error: str | None):
- validate_horoscope(text)
- validate_tarot(text)
- validate_card_of_day(text)

Forbidden patterns to filter (AI self-references):
- r"(?i)я\s+(не\s+)?AI"
- r"(?i)как\s+языковая\s+модель"
- r"(?i)я\s+не\s+могу"
- r"(?i)извините,?\s+но"
- r"(?i)as\s+an?\s+AI"

**4. src/services/ai/cache.py:**
Simple in-memory dict with TTL (expires at end of day):
- CacheEntry TypedDict with text, cached_at, expires_date
- _horoscope_cache: dict[str, CacheEntry] (key = zodiac_sign.lower())
- _card_of_day_cache: dict[str, CacheEntry] (key = str(user_id))

Async functions:
- get_cached_horoscope(zodiac_sign) -> str | None
- set_cached_horoscope(zodiac_sign, text) -> None
- get_cached_card_of_day(user_id) -> tuple[str, dict, bool] | None (text, card, reversed)
- set_cached_card_of_day(user_id, text, card, is_reversed) -> None
- clear_expired_cache() -> None (for optional scheduler cleanup)

Expiry check: date.today() > entry["expires_date"]

**5. src/services/ai/client.py:**
AIService class:
```python
class AIService:
    MAX_VALIDATION_RETRIES = 2

    def __init__(self):
        self.client = AsyncOpenAI(
            base_url="https://openrouter.ai/api/v1",
            api_key=settings.openrouter_api_key,
            timeout=30.0,
            max_retries=3,
        )
        self.model = "openai/gpt-4o-mini"

    async def _generate(self, system_prompt: str, user_prompt: str, max_tokens: int = 1500) -> str | None:
        # Try API call, return None on APIError
        # Include extra_headers: HTTP-Referer, X-Title

    async def generate_horoscope(self, zodiac_sign: str, zodiac_sign_ru: str, date_str: str) -> str | None:
        # Check cache first
        # Generate with validation retry loop (up to MAX_VALIDATION_RETRIES)
        # Cache on success
        # Return None if all retries fail

    async def generate_tarot_interpretation(self, question: str, cards: list[dict], is_reversed: list[bool]) -> str | None:
        # No caching (depends on question)
        # Validation retry loop

    async def generate_card_of_day(self, user_id: int, card: dict, is_reversed: bool) -> str | None:
        # Check cache first
        # Generate with validation retry
        # Cache on success
```

Singleton:
```python
_ai_service: AIService | None = None

def get_ai_service() -> AIService:
    global _ai_service
    if _ai_service is None:
        _ai_service = AIService()
    return _ai_service
```

Use structlog for logging (logger = structlog.get_logger()).
  </action>
  <verify>
    - `python -c "from src.services.ai import AIService, get_ai_service"` works
    - `python -c "from src.services.ai.prompts import HoroscopePrompt, TarotSpreadPrompt, CardOfDayPrompt"` works
    - `python -c "from src.services.ai.validators import validate_horoscope, validate_tarot, validate_card_of_day"` works
    - `python -c "from src.services.ai.cache import get_cached_horoscope, set_cached_horoscope"` works
  </verify>
  <done>Complete AI service module with client, prompts, validators, cache</done>
</task>

</tasks>

<verification>
After both tasks:
1. All imports work without errors
2. `poetry check` passes
3. `ruff check src/services/ai/` passes (no lint errors)
</verification>

<success_criteria>
- [ ] openai and tenacity packages installed
- [ ] OPENROUTER_API_KEY in Settings
- [ ] src/services/ai/ module complete with 5 files
- [ ] AIService has generate_horoscope, generate_tarot_interpretation, generate_card_of_day
- [ ] Prompts use Russian, friendly tone, Barnum effect
- [ ] Validators check length, structure, filter AI self-references
- [ ] Cache uses date-based TTL
- [ ] All imports work
</success_criteria>

<output>
After completion, create `.planning/phases/05-ai-integration/05-01-SUMMARY.md`
</output>
