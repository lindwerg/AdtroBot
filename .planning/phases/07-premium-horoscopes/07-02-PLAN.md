---
phase: 07-premium-horoscopes
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/bot/states/birth_data.py
  - src/bot/callbacks/birth_data.py
  - src/bot/keyboards/birth_data.py
  - src/bot/handlers/birth_data.py
  - src/bot/handlers/__init__.py
  - src/bot/keyboards/profile.py
autonomous: true

must_haves:
  truths:
    - "Premium пользователь может ввести время рождения через FSM"
    - "Premium пользователь может выбрать город рождения из списка результатов"
    - "После выбора города данные сохраняются в User (birth_time, birth_city, birth_lat, birth_lon)"
  artifacts:
    - path: "src/bot/states/birth_data.py"
      provides: "FSM states for birth data collection"
      exports: ["BirthDataStates"]
    - path: "src/bot/handlers/birth_data.py"
      provides: "Handlers for birth time/city input"
      min_lines: 80
    - path: "src/bot/keyboards/birth_data.py"
      provides: "Keyboards for city selection"
      exports: ["build_city_selection_keyboard"]
  key_links:
    - from: "src/bot/handlers/birth_data.py"
      to: "src/services/astrology/geocoding.py"
      via: "search_city call"
      pattern: "search_city"
    - from: "src/bot/handlers/birth_data.py"
      to: "src/db/models/user.py"
      via: "Update birth fields"
      pattern: "user\\.birth_"
---

<objective>
Создать FSM для ввода времени и места рождения premium пользователя.

Purpose: Позволить пользователю указать данные для персонализированной натальной карты
Output: Полный flow: кнопка в профиле -> ввод времени -> ввод города -> выбор из списка -> сохранение
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-premium-horoscopes/07-RESEARCH.md
@.planning/phases/07-premium-horoscopes/07-01-SUMMARY.md

@src/bot/states/onboarding.py
@src/bot/handlers/profile.py
@src/bot/keyboards/profile.py
@src/services/astrology/geocoding.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FSM states and callbacks for birth data</name>
  <files>
    src/bot/states/birth_data.py
    src/bot/callbacks/birth_data.py
  </files>
  <action>
1. Создать src/bot/states/birth_data.py:
   ```python
   """Birth data collection FSM states."""

   from aiogram.fsm.state import State, StatesGroup


   class BirthDataStates(StatesGroup):
       """States for collecting birth time and place."""

       waiting_birth_time = State()   # Ожидаем ввод времени (HH:MM или "не знаю")
       waiting_birth_city = State()   # Ожидаем ввод названия города
       selecting_city = State()       # Ожидаем выбор города из списка
   ```

2. Создать src/bot/callbacks/birth_data.py:
   ```python
   """Birth data callbacks."""

   from aiogram.filters.callback_data import CallbackData


   class CitySelectCallback(CallbackData, prefix="bcity"):
       """Callback for city selection from geocoding results."""
       idx: int  # Index in results list (0-4)


   class SkipTimeCallback(CallbackData, prefix="bskip"):
       """Callback for skipping birth time input."""
       pass
   ```
  </action>
  <verify>
    python -c "from src.bot.states.birth_data import BirthDataStates; print(BirthDataStates.waiting_birth_time)"
    python -c "from src.bot.callbacks.birth_data import CitySelectCallback; print(CitySelectCallback(idx=0).pack())"
  </verify>
  <done>FSM states и callbacks созданы и импортируются без ошибок</done>
</task>

<task type="auto">
  <name>Task 2: Create keyboards for birth data input</name>
  <files>
    src/bot/keyboards/birth_data.py
  </files>
  <action>
1. Создать src/bot/keyboards/birth_data.py:
   ```python
   """Keyboards for birth data collection."""

   from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
   from aiogram.utils.keyboard import InlineKeyboardBuilder

   from src.bot.callbacks.birth_data import CitySelectCallback, SkipTimeCallback
   from src.services.astrology.geocoding import CityResult


   def build_skip_time_keyboard() -> InlineKeyboardMarkup:
       """Build keyboard with 'I don't know' button for birth time."""
       builder = InlineKeyboardBuilder()
       builder.row(
           InlineKeyboardButton(
               text="Не знаю время рождения",
               callback_data=SkipTimeCallback().pack(),
           )
       )
       builder.row(
           InlineKeyboardButton(
               text="Отмена",
               callback_data="cancel_birth_data",
           )
       )
       return builder.as_markup()


   def build_city_selection_keyboard(
       cities: list[CityResult],
   ) -> InlineKeyboardMarkup:
       """Build keyboard for selecting city from search results.

       Args:
           cities: List of CityResult from geocoding

       Returns:
           Keyboard with city buttons + retry/cancel
       """
       builder = InlineKeyboardBuilder()

       for idx, city in enumerate(cities[:5]):  # Max 5 results
           # Truncate long names
           display_name = city.name[:40] + "..." if len(city.name) > 40 else city.name
           builder.row(
               InlineKeyboardButton(
                   text=display_name,
                   callback_data=CitySelectCallback(idx=idx).pack(),
               )
           )

       # Retry and cancel buttons
       builder.row(
           InlineKeyboardButton(
               text="Ввести другой город",
               callback_data="retry_city_search",
           ),
           InlineKeyboardButton(
               text="Отмена",
               callback_data="cancel_birth_data",
           ),
       )

       return builder.as_markup()


   def build_birth_data_complete_keyboard() -> InlineKeyboardMarkup:
       """Build keyboard after successful birth data save."""
       builder = InlineKeyboardBuilder()
       builder.row(
           InlineKeyboardButton(
               text="Посмотреть гороскоп",
               callback_data="menu_horoscope",
           )
       )
       builder.row(
           InlineKeyboardButton(
               text="Главное меню",
               callback_data="main_menu",
           )
       )
       return builder.as_markup()
   ```
  </action>
  <verify>
    python -c "from src.bot.keyboards.birth_data import build_skip_time_keyboard; print(build_skip_time_keyboard())"
  </verify>
  <done>Keyboards для birth data созданы: skip_time, city_selection, complete</done>
</task>

<task type="auto">
  <name>Task 3: Create birth data handlers + integrate into profile</name>
  <files>
    src/bot/handlers/birth_data.py
    src/bot/handlers/__init__.py
    src/bot/keyboards/profile.py
  </files>
  <action>
1. Создать src/bot/handlers/birth_data.py:
   ```python
   """Handlers for birth data collection (time and place)."""

   from datetime import time

   from aiogram import F, Router
   from aiogram.fsm.context import FSMContext
   from aiogram.types import CallbackQuery, Message
   from sqlalchemy import select
   from sqlalchemy.ext.asyncio import AsyncSession

   import structlog

   from src.bot.callbacks.birth_data import CitySelectCallback, SkipTimeCallback
   from src.bot.keyboards.birth_data import (
       build_birth_data_complete_keyboard,
       build_city_selection_keyboard,
       build_skip_time_keyboard,
   )
   from src.bot.states.birth_data import BirthDataStates
   from src.db.models.user import User
   from src.services.astrology.geocoding import CityResult, search_city

   logger = structlog.get_logger()
   router = Router(name="birth_data")


   @router.callback_query(F.data == "setup_birth_data")
   async def start_birth_data_setup(
       callback: CallbackQuery,
       state: FSMContext,
       session: AsyncSession,
   ) -> None:
       """Start birth data collection flow."""
       # Check if user is premium
       stmt = select(User).where(User.telegram_id == callback.from_user.id)
       result = await session.execute(stmt)
       user = result.scalar_one_or_none()

       if not user:
           await callback.answer("Профиль не найден", show_alert=True)
           return

       if not user.is_premium:
           await callback.answer(
               "Эта функция доступна только для Premium подписчиков",
               show_alert=True,
           )
           return

       await state.set_state(BirthDataStates.waiting_birth_time)
       await callback.message.edit_text(
           "Введи время рождения в формате ЧЧ:ММ\n"
           "Например: 14:30 или 09:15\n\n"
           "Если не знаешь точное время - нажми кнопку ниже.",
           reply_markup=build_skip_time_keyboard(),
       )
       await callback.answer()


   @router.callback_query(SkipTimeCallback.filter(), BirthDataStates.waiting_birth_time)
   async def skip_birth_time(
       callback: CallbackQuery,
       state: FSMContext,
   ) -> None:
       """Handle 'I don't know' for birth time."""
       await state.update_data(birth_time=None)
       await state.set_state(BirthDataStates.waiting_birth_city)
       await callback.message.edit_text(
           "Хорошо, используем приблизительное время (полдень).\n\n"
           "Теперь введи город рождения:",
       )
       await callback.answer()


   @router.message(BirthDataStates.waiting_birth_time)
   async def process_birth_time(
       message: Message,
       state: FSMContext,
   ) -> None:
       """Process birth time input."""
       text = message.text.strip()

       # Parse time in HH:MM format
       try:
           parts = text.replace(".", ":").split(":")
           if len(parts) != 2:
               raise ValueError("Invalid format")

           hour = int(parts[0])
           minute = int(parts[1])

           if not (0 <= hour <= 23 and 0 <= minute <= 59):
               raise ValueError("Invalid time range")

           birth_time = time(hour, minute)
           await state.update_data(birth_time=birth_time)
           await state.set_state(BirthDataStates.waiting_birth_city)
           await message.answer(
               f"Время рождения: {hour:02d}:{minute:02d}\n\n"
               "Теперь введи город рождения:"
           )

       except (ValueError, IndexError):
           await message.answer(
               "Не могу распознать время. Введи в формате ЧЧ:ММ\n"
               "Например: 14:30 или 09:15",
               reply_markup=build_skip_time_keyboard(),
           )


   @router.message(BirthDataStates.waiting_birth_city)
   async def process_birth_city(
       message: Message,
       state: FSMContext,
   ) -> None:
       """Process city name input and search."""
       query = message.text.strip()

       if len(query) < 2:
           await message.answer("Введи хотя бы 2 символа для поиска города.")
           return

       # Search for cities
       cities = await search_city(query, max_results=5)

       if not cities:
           await message.answer(
               f'Город "{query}" не найден. Попробуй другое название или проверь написание.'
           )
           return

       # Store cities in state for selection
       await state.update_data(
           cities=[
               {
                   "name": c.name,
                   "lat": c.latitude,
                   "lon": c.longitude,
                   "tz": c.timezone,
               }
               for c in cities
           ]
       )
       await state.set_state(BirthDataStates.selecting_city)

       await message.answer(
           "Выбери свой город из списка:",
           reply_markup=build_city_selection_keyboard(cities),
       )


   @router.callback_query(CitySelectCallback.filter(), BirthDataStates.selecting_city)
   async def select_city(
       callback: CallbackQuery,
       callback_data: CitySelectCallback,
       state: FSMContext,
       session: AsyncSession,
   ) -> None:
       """Handle city selection and save birth data."""
       data = await state.get_data()
       cities = data.get("cities", [])

       if callback_data.idx >= len(cities):
           await callback.answer("Город не найден", show_alert=True)
           return

       city = cities[callback_data.idx]
       birth_time = data.get("birth_time")  # time object or None

       # Update user in database
       stmt = select(User).where(User.telegram_id == callback.from_user.id)
       result = await session.execute(stmt)
       user = result.scalar_one_or_none()

       if not user:
           await callback.answer("Профиль не найден", show_alert=True)
           return

       user.birth_time = birth_time
       user.birth_city = city["name"]
       user.birth_lat = city["lat"]
       user.birth_lon = city["lon"]

       await session.commit()
       await state.clear()

       time_str = f"{birth_time.hour:02d}:{birth_time.minute:02d}" if birth_time else "неизвестно (полдень)"

       await callback.message.edit_text(
           f"Данные сохранены!\n\n"
           f"Время рождения: {time_str}\n"
           f"Место рождения: {city['name']}\n\n"
           "Теперь твои гороскопы будут персонализированы на основе натальной карты!",
           reply_markup=build_birth_data_complete_keyboard(),
       )
       await callback.answer("Сохранено!")

       logger.info(
           "birth_data_saved",
           user_id=callback.from_user.id,
           city=city["name"],
           has_time=birth_time is not None,
       )


   @router.callback_query(F.data == "retry_city_search", BirthDataStates.selecting_city)
   async def retry_city_search(
       callback: CallbackQuery,
       state: FSMContext,
   ) -> None:
       """Allow user to search for another city."""
       await state.set_state(BirthDataStates.waiting_birth_city)
       await callback.message.edit_text("Введи название города:")
       await callback.answer()


   @router.callback_query(F.data == "cancel_birth_data")
   async def cancel_birth_data(
       callback: CallbackQuery,
       state: FSMContext,
   ) -> None:
       """Cancel birth data collection."""
       await state.clear()
       await callback.message.edit_text(
           "Настройка натальной карты отменена.\n"
           "Ты можешь вернуться к этому в любой момент через профиль."
       )
       await callback.answer()
   ```

2. Добавить router в src/bot/handlers/__init__.py:
   - import: from src.bot.handlers.birth_data import router as birth_data_router
   - Добавить birth_data_router в список routers

3. Добавить кнопку в profile keyboards (src/bot/keyboards/profile.py):
   - Добавить функцию build_profile_actions_keyboard(is_premium: bool, has_birth_data: bool)
   - Для premium пользователей показывать кнопку "Настроить натальную карту" с callback_data="setup_birth_data"
   - Если birth_data уже есть - показывать "Изменить данные рождения"
  </action>
  <verify>
    python -c "from src.bot.handlers.birth_data import router; print(router.name)"
    python -c "from src.bot.keyboards.birth_data import build_city_selection_keyboard; print('OK')"
  </verify>
  <done>Birth data FSM полностью работает: ввод времени -> ввод города -> выбор -> сохранение в БД</done>
</task>

</tasks>

<verification>
1. FSM states: `python -c "from src.bot.states.birth_data import BirthDataStates; print(len(list(BirthDataStates)))"`  # 3
2. Handlers: `python -c "from src.bot.handlers.birth_data import router; print(len(router.callback_query.handlers))"`  # >= 5
3. Integration: `python -c "from src.bot.handlers import birth_data_router; print(birth_data_router.name)"`  # birth_data
4. Tests: `pytest tests/ -v`  # Все тесты проходят
</verification>

<success_criteria>
1. FSM с 3 состояниями: waiting_birth_time, waiting_birth_city, selecting_city
2. Парсинг времени HH:MM с валидацией
3. Поиск города через geocoding с показом до 5 результатов
4. Сохранение birth_time, birth_city, birth_lat, birth_lon в User
5. Кнопка "Настроить натальную карту" доступна только premium пользователям
</success_criteria>

<output>
After completion, create `.planning/phases/07-premium-horoscopes/07-02-SUMMARY.md`
</output>
