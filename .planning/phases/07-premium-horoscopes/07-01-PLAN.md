---
phase: 07-premium-horoscopes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/models/user.py
  - alembic/versions/*_add_birth_location_fields.py
  - src/config.py
  - src/services/astrology/__init__.py
  - src/services/astrology/natal_chart.py
  - src/services/astrology/geocoding.py
  - pyproject.toml
autonomous: true

must_haves:
  truths:
    - "User model содержит поля для времени и места рождения"
    - "flatlib вычисляет позиции Sun, Moon, Ascendant"
    - "Geocoding возвращает координаты и timezone по названию города"
  artifacts:
    - path: "src/db/models/user.py"
      provides: "Birth location fields: birth_time, birth_city, birth_lat, birth_lon"
      contains: "birth_time"
    - path: "src/services/astrology/natal_chart.py"
      provides: "Natal chart calculation with flatlib"
      exports: ["calculate_natal_chart"]
    - path: "src/services/astrology/geocoding.py"
      provides: "City geocoding via GeoNames"
      exports: ["GeocodingService", "search_city"]
  key_links:
    - from: "src/services/astrology/natal_chart.py"
      to: "flatlib"
      via: "Chart calculation"
      pattern: "from flatlib"
    - from: "src/services/astrology/geocoding.py"
      to: "geopy"
      via: "GeoNames geocoder"
      pattern: "from geopy"
---

<objective>
Создать инфраструктуру для premium гороскопов: расширить User model, добавить astrology сервис (натальная карта) и geocoding сервис.

Purpose: Фундамент для персонализированных гороскопов на основе натальной карты
Output: User model с birth_time/birth_city/birth_lat/birth_lon, AstrologyService с flatlib, GeocodingService с GeoNames
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-premium-horoscopes/07-RESEARCH.md

@src/db/models/user.py
@src/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add birth location fields to User model + migration</name>
  <files>
    src/db/models/user.py
    alembic/versions/*_add_birth_location_fields.py
  </files>
  <action>
1. Добавить в User model (src/db/models/user.py) новые поля:
   - birth_time: Mapped[time | None] = mapped_column(Time, nullable=True)  # Time of birth (None = unknown, use noon)
   - birth_city: Mapped[str | None] = mapped_column(String(255), nullable=True)  # City name for display
   - birth_lat: Mapped[float | None] = mapped_column(Float, nullable=True)  # Latitude
   - birth_lon: Mapped[float | None] = mapped_column(Float, nullable=True)  # Longitude

2. Добавить импорт: from sqlalchemy import Time, Float

3. Создать миграцию:
   alembic revision --autogenerate -m "add_birth_location_fields"

4. Применить миграцию:
   alembic upgrade head
  </action>
  <verify>
    alembic current  # Должен показать новую миграцию
    python -c "from src.db.models.user import User; print([c.name for c in User.__table__.columns if 'birth' in c.name])"  # Должен показать birth_time, birth_city, birth_lat, birth_lon
  </verify>
  <done>User model содержит 4 новых поля: birth_time, birth_city, birth_lat, birth_lon. Миграция применена.</done>
</task>

<task type="auto">
  <name>Task 2: Install astrology dependencies + create natal chart service</name>
  <files>
    pyproject.toml
    src/services/astrology/__init__.py
    src/services/astrology/natal_chart.py
  </files>
  <action>
1. Установить зависимости:
   poetry add flatlib pyswisseph

2. Создать директорию src/services/astrology/

3. Создать src/services/astrology/__init__.py:
   ```python
   from src.services.astrology.natal_chart import calculate_natal_chart
   from src.services.astrology.geocoding import GeocodingService, search_city

   __all__ = ["calculate_natal_chart", "GeocodingService", "search_city"]
   ```

4. Создать src/services/astrology/natal_chart.py:
   - Функция calculate_natal_chart(birth_date: date, birth_time: time | None, latitude: float, longitude: float) -> dict
   - Использовать flatlib для расчета:
     - Sun sign + degree
     - Moon sign + degree
     - Ascendant sign + degree (если время известно)
   - Возвращать dict:
     ```python
     {
         "sun_sign": "Aries",
         "sun_degree": 15.3,
         "moon_sign": "Cancer",
         "moon_degree": 22.1,
         "ascendant": "Leo",  # или None если время неизвестно
         "ascendant_degree": 8.5,  # или None
         "time_known": True/False,
     }
     ```
   - Если birth_time is None, использовать 12:00 (noon chart)
   - Логировать ошибки через structlog

5. Паттерн для flatlib GeoPos (из research):
   ```python
   from flatlib.datetime import Datetime
   from flatlib.geopos import GeoPos
   from flatlib.chart import Chart
   from flatlib import const

   # Format latitude: "55n45" for 55.75 N, "55s45" for -55.75 S
   lat_dir = 'n' if latitude >= 0 else 's'
   lat_deg = int(abs(latitude))
   lat_min = int((abs(latitude) % 1) * 60)

   lon_dir = 'e' if longitude >= 0 else 'w'
   lon_deg = int(abs(longitude))
   lon_min = int((abs(longitude) % 1) * 60)

   pos = GeoPos(f"{lat_deg}{lat_dir}{lat_min:02d}", f"{lon_deg}{lon_dir}{lon_min:02d}")
   ```
  </action>
  <verify>
    poetry run python -c "from src.services.astrology import calculate_natal_chart; from datetime import date; print(calculate_natal_chart(date(1990, 3, 21), None, 55.75, 37.62))"
    # Должен вернуть dict с sun_sign="Aries" или близко (21 марта = начало Овна)
  </verify>
  <done>flatlib установлен, calculate_natal_chart возвращает Sun/Moon/Ascendant позиции для заданных координат</done>
</task>

<task type="auto">
  <name>Task 3: Create geocoding service with GeoNames</name>
  <files>
    src/config.py
    src/services/astrology/geocoding.py
  </files>
  <action>
1. Добавить в src/config.py:
   ```python
   # GeoNames
   geonames_username: str = Field(
       default="demo",  # Create account at geonames.org for production
       validation_alias="GEONAMES_USERNAME",
   )
   ```

2. Установить geopy:
   poetry add geopy

3. Создать src/services/astrology/geocoding.py:
   ```python
   """City geocoding service using GeoNames."""

   import asyncio
   from dataclasses import dataclass

   import structlog
   from geopy.geocoders import GeoNames
   from geopy.exc import GeocoderTimedOut, GeocoderServiceError

   from src.config import settings

   logger = structlog.get_logger()


   @dataclass
   class CityResult:
       """Geocoding result for a city."""
       name: str  # Full name with country (e.g., "Moscow, Russia")
       latitude: float
       longitude: float
       timezone: str  # IANA timezone (e.g., "Europe/Moscow")


   class GeocodingService:
       """Service for geocoding birth cities."""

       def __init__(self, username: str | None = None):
           self.geolocator = GeoNames(
               username=username or settings.geonames_username,
               timeout=10,
           )

       async def search_city(
           self,
           query: str,
           max_results: int = 5,
       ) -> list[CityResult]:
           """Search for cities matching query.

           Args:
               query: City name to search
               max_results: Maximum results to return

           Returns:
               List of CityResult with coordinates and timezone
           """
           try:
               loop = asyncio.get_event_loop()
               results = await loop.run_in_executor(
                   None,
                   lambda: self.geolocator.geocode(
                       query,
                       exactly_one=False,
                       timeout=10,
                   )
               )

               if not results:
                   return []

               cities = []
               for loc in results[:max_results]:
                   # Extract timezone from raw GeoNames response
                   tz = loc.raw.get("timezone", {})
                   timezone_id = tz.get("timezoneId", "UTC") if isinstance(tz, dict) else "UTC"

                   cities.append(CityResult(
                       name=loc.address,
                       latitude=loc.latitude,
                       longitude=loc.longitude,
                       timezone=timezone_id,
                   ))

               logger.debug("geocoding_search", query=query, results=len(cities))
               return cities

           except (GeocoderTimedOut, GeocoderServiceError) as e:
               logger.error("geocoding_failed", error=str(e), query=query)
               return []
           except Exception as e:
               logger.error("geocoding_unexpected_error", error=str(e), query=query)
               return []


   # Singleton instance
   _geocoding_service: GeocodingService | None = None


   def get_geocoding_service() -> GeocodingService:
       """Get geocoding service singleton."""
       global _geocoding_service
       if _geocoding_service is None:
           _geocoding_service = GeocodingService()
       return _geocoding_service


   async def search_city(query: str, max_results: int = 5) -> list[CityResult]:
       """Convenience function for city search."""
       service = get_geocoding_service()
       return await service.search_city(query, max_results)
   ```
  </action>
  <verify>
    poetry run python -c "import asyncio; from src.services.astrology.geocoding import search_city; print(asyncio.run(search_city('Moscow')))"
    # Должен вернуть список CityResult с Moscow, Russia и координатами ~55.75, 37.62
  </verify>
  <done>GeocodingService работает: search_city('Moscow') возвращает координаты и timezone Europe/Moscow</done>
</task>

</tasks>

<verification>
1. User model: `python -c "from src.db.models.user import User; print('birth_time' in [c.name for c in User.__table__.columns])"`  # True
2. Natal chart: `python -c "from src.services.astrology import calculate_natal_chart; from datetime import date; r=calculate_natal_chart(date(1990,6,15), None, 55.75, 37.62); print(r['sun_sign'])"`  # Gemini
3. Geocoding: `python -c "import asyncio; from src.services.astrology import search_city; r=asyncio.run(search_city('Москва')); print(r[0].name if r else 'NO RESULTS')"`  # Moscow, Russia или similar
4. Tests: `pytest tests/ -v`  # Все существующие тесты проходят
</verification>

<success_criteria>
1. User model содержит birth_time, birth_city, birth_lat, birth_lon
2. calculate_natal_chart вычисляет Sun/Moon/Ascendant позиции
3. search_city возвращает координаты и timezone
4. Миграция применена без ошибок
5. Все зависимости установлены (flatlib, pyswisseph, geopy)
</success_criteria>

<output>
After completion, create `.planning/phases/07-premium-horoscopes/07-01-SUMMARY.md`
</output>
