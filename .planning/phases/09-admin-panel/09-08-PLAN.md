---
phase: 09-admin-panel
plan: 08
type: execute
wave: 4
depends_on: ["09-02", "09-04"]
files_modified:
  - src/admin/services/payments.py
  - src/admin/router.py
  - src/admin/schemas.py
  - admin-frontend/src/pages/Payments.tsx
  - admin-frontend/src/pages/Subscriptions.tsx
  - admin-frontend/src/api/endpoints/payments.ts
  - admin-frontend/src/routes/index.tsx
autonomous: true

must_haves:
  truths:
    - "Payments page shows all payments with filters and pagination"
    - "Subscriptions page shows all subscriptions with status management"
    - "Admin can view payment details"
    - "Admin can change subscription status"
  artifacts:
    - path: "src/admin/services/payments.py"
      provides: "Payments and subscriptions service"
      exports: ["list_payments", "list_subscriptions", "update_subscription_status"]
    - path: "admin-frontend/src/pages/Payments.tsx"
      provides: "Payments list page"
    - path: "admin-frontend/src/pages/Subscriptions.tsx"
      provides: "Subscriptions management page"
  key_links:
    - from: "src/admin/router.py"
      to: "src/admin/services/payments.py"
      via: "endpoint calls"
      pattern: "list_payments|list_subscriptions"
---

<objective>
Create payments and subscriptions management pages.

Purpose: Enable admin to view all payments and manage subscriptions.
Output: Payments and subscriptions pages with list, filters, and actions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-admin-panel/09-CONTEXT.md
@.planning/phases/09-admin-panel/09-RESEARCH.md
@.planning/phases/09-admin-panel/09-02-SUMMARY.md
@.planning/phases/09-admin-panel/09-04-SUMMARY.md
@src/db/models/payment.py
@src/db/models/subscription.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Payments and subscriptions schemas</name>
  <files>
    - src/admin/schemas.py
  </files>
  <action>
    Add payments and subscriptions schemas to src/admin/schemas.py:

    ```python
    class PaymentListItem(BaseModel):
        id: str
        user_id: int
        subscription_id: int | None
        amount: int  # kopeks
        currency: str
        status: str
        is_recurring: bool
        description: str | None
        created_at: datetime
        paid_at: datetime | None

        # Joined user info
        user_telegram_id: int | None = None
        user_username: str | None = None

        model_config = ConfigDict(from_attributes=True)

    class PaymentListResponse(BaseModel):
        items: list[PaymentListItem]
        total: int
        page: int
        page_size: int
        total_amount: int  # Sum of all filtered payments (kopeks)

    class SubscriptionListItem(BaseModel):
        id: int
        user_id: int
        plan: str
        status: str
        payment_method_id: str | None
        started_at: datetime
        current_period_start: datetime
        current_period_end: datetime
        canceled_at: datetime | None
        created_at: datetime

        # Joined user info
        user_telegram_id: int | None = None
        user_username: str | None = None

        model_config = ConfigDict(from_attributes=True)

    class SubscriptionListResponse(BaseModel):
        items: list[SubscriptionListItem]
        total: int
        page: int
        page_size: int

    class UpdateSubscriptionStatusRequest(BaseModel):
        status: str  # active, canceled, expired
    ```
  </action>
  <verify>
    - Import works without errors
    - Schemas can be instantiated
  </verify>
  <done>Payment and subscription schemas defined</done>
</task>

<task type="auto">
  <name>Task 2: Payments service and API</name>
  <files>
    - src/admin/services/payments.py
    - src/admin/router.py
  </files>
  <action>
    1. Create src/admin/services/payments.py:
       ```python
       """Payments and subscriptions service."""

       from datetime import datetime
       from sqlalchemy import select, func, or_
       from sqlalchemy.ext.asyncio import AsyncSession
       from sqlalchemy.orm import aliased

       from src.db.models.payment import Payment
       from src.db.models.subscription import Subscription
       from src.db.models.user import User
       from src.admin.schemas import (
           PaymentListItem, PaymentListResponse,
           SubscriptionListItem, SubscriptionListResponse,
           UpdateSubscriptionStatusRequest
       )


       async def list_payments(
           session: AsyncSession,
           page: int = 1,
           page_size: int = 20,
           status: str | None = None,
           user_search: str | None = None,
           date_from: datetime | None = None,
           date_to: datetime | None = None,
       ) -> PaymentListResponse:
           """List payments with filters and pagination."""
           query = (
               select(
                   Payment,
                   User.telegram_id.label("user_telegram_id"),
                   User.username.label("user_username"),
               )
               .join(User, Payment.user_id == User.id)
           )

           # Filters
           if status:
               query = query.where(Payment.status == status)

           if user_search:
               if user_search.isdigit():
                   query = query.where(User.telegram_id == int(user_search))
               else:
                   query = query.where(User.username.ilike(f"%{user_search}%"))

           if date_from:
               query = query.where(Payment.created_at >= date_from)
           if date_to:
               query = query.where(Payment.created_at <= date_to)

           # Count total
           count_query = select(func.count()).select_from(Payment)
           if status:
               count_query = count_query.where(Payment.status == status)
           total = await session.scalar(count_query) or 0

           # Sum amount for filtered payments
           sum_query = select(func.coalesce(func.sum(Payment.amount), 0))
           if status:
               sum_query = sum_query.where(Payment.status == status)
           if status == "succeeded" or not status:
               sum_query = sum_query.where(Payment.status == "succeeded")
           total_amount = await session.scalar(sum_query) or 0

           # Order and paginate
           query = query.order_by(Payment.created_at.desc())
           query = query.offset((page - 1) * page_size).limit(page_size)

           result = await session.execute(query)
           rows = result.all()

           items = []
           for row in rows:
               payment = row[0]
               item = PaymentListItem(
                   id=payment.id,
                   user_id=payment.user_id,
                   subscription_id=payment.subscription_id,
                   amount=payment.amount,
                   currency=payment.currency,
                   status=payment.status,
                   is_recurring=payment.is_recurring,
                   description=payment.description,
                   created_at=payment.created_at,
                   paid_at=payment.paid_at,
                   user_telegram_id=row[1],
                   user_username=row[2],
               )
               items.append(item)

           return PaymentListResponse(
               items=items,
               total=total,
               page=page,
               page_size=page_size,
               total_amount=total_amount,
           )


       async def list_subscriptions(
           session: AsyncSession,
           page: int = 1,
           page_size: int = 20,
           status: str | None = None,
           plan: str | None = None,
           user_search: str | None = None,
       ) -> SubscriptionListResponse:
           """List subscriptions with filters and pagination."""
           query = (
               select(
                   Subscription,
                   User.telegram_id.label("user_telegram_id"),
                   User.username.label("user_username"),
               )
               .join(User, Subscription.user_id == User.id)
           )

           # Filters
           if status:
               query = query.where(Subscription.status == status)
           if plan:
               query = query.where(Subscription.plan == plan)
           if user_search:
               if user_search.isdigit():
                   query = query.where(User.telegram_id == int(user_search))
               else:
                   query = query.where(User.username.ilike(f"%{user_search}%"))

           # Count
           count_query = select(func.count()).select_from(Subscription)
           if status:
               count_query = count_query.where(Subscription.status == status)
           total = await session.scalar(count_query) or 0

           # Order and paginate
           query = query.order_by(Subscription.created_at.desc())
           query = query.offset((page - 1) * page_size).limit(page_size)

           result = await session.execute(query)
           rows = result.all()

           items = []
           for row in rows:
               sub = row[0]
               item = SubscriptionListItem(
                   id=sub.id,
                   user_id=sub.user_id,
                   plan=sub.plan,
                   status=sub.status,
                   payment_method_id=sub.payment_method_id,
                   started_at=sub.started_at,
                   current_period_start=sub.current_period_start,
                   current_period_end=sub.current_period_end,
                   canceled_at=sub.canceled_at,
                   created_at=sub.created_at,
                   user_telegram_id=row[1],
                   user_username=row[2],
               )
               items.append(item)

           return SubscriptionListResponse(
               items=items,
               total=total,
               page=page,
               page_size=page_size,
           )


       async def update_subscription_status(
           session: AsyncSession,
           subscription_id: int,
           request: UpdateSubscriptionStatusRequest,
       ) -> bool:
           """Update subscription status."""
           sub = await session.get(Subscription, subscription_id)
           if not sub:
               return False

           sub.status = request.status

           # Update user premium status if needed
           user = await session.get(User, sub.user_id)
           if user:
               if request.status in ("canceled", "expired"):
                   user.is_premium = False
                   user.daily_spread_limit = 1
               elif request.status == "active":
                   user.is_premium = True
                   user.daily_spread_limit = 20

           await session.commit()
           return True
       ```

    2. Add endpoints to src/admin/router.py:
       ```python
       from src.admin.services.payments import (
           list_payments, list_subscriptions, update_subscription_status
       )
       from src.admin.schemas import (
           PaymentListResponse, SubscriptionListResponse, UpdateSubscriptionStatusRequest
       )

       @admin_router.get("/payments", response_model=PaymentListResponse)
       async def payments_list(
           page: int = Query(1, ge=1),
           page_size: int = Query(20, ge=1, le=100),
           status: str | None = Query(None),
           user_search: str | None = Query(None),
           session: AsyncSession = Depends(get_session),
           current_admin: Admin = Depends(get_current_admin),
       ):
           """List payments."""
           return await list_payments(
               session,
               page=page,
               page_size=page_size,
               status=status,
               user_search=user_search,
           )

       @admin_router.get("/subscriptions", response_model=SubscriptionListResponse)
       async def subscriptions_list(
           page: int = Query(1, ge=1),
           page_size: int = Query(20, ge=1, le=100),
           status: str | None = Query(None),
           plan: str | None = Query(None),
           user_search: str | None = Query(None),
           session: AsyncSession = Depends(get_session),
           current_admin: Admin = Depends(get_current_admin),
       ):
           """List subscriptions."""
           return await list_subscriptions(
               session,
               page=page,
               page_size=page_size,
               status=status,
               plan=plan,
               user_search=user_search,
           )

       @admin_router.patch("/subscriptions/{subscription_id}")
       async def update_sub_status(
           subscription_id: int = Path(...),
           request: UpdateSubscriptionStatusRequest = ...,
           session: AsyncSession = Depends(get_session),
           current_admin: Admin = Depends(get_current_admin),
       ):
           """Update subscription status."""
           success = await update_subscription_status(session, subscription_id, request)
           if not success:
               raise HTTPException(status_code=404, detail="Subscription not found")
           return {"status": "ok"}
       ```
  </action>
  <verify>
    - App starts without errors
    - GET /admin/payments returns list
    - GET /admin/subscriptions returns list
    - PATCH /admin/subscriptions/{id} works
  </verify>
  <done>Payments and subscriptions API endpoints</done>
</task>

<task type="auto">
  <name>Task 3: Frontend pages</name>
  <files>
    - admin-frontend/src/api/endpoints/payments.ts
    - admin-frontend/src/pages/Payments.tsx
    - admin-frontend/src/pages/Subscriptions.tsx
    - admin-frontend/src/routes/index.tsx
  </files>
  <action>
    1. Create admin-frontend/src/api/endpoints/payments.ts:
       ```typescript
       import { api } from '@/api/client'

       export interface PaymentListItem {
         id: string
         user_id: number
         subscription_id: number | null
         amount: number
         currency: string
         status: string
         is_recurring: boolean
         description: string | null
         created_at: string
         paid_at: string | null
         user_telegram_id: number | null
         user_username: string | null
       }

       export interface PaymentListResponse {
         items: PaymentListItem[]
         total: number
         page: number
         page_size: number
         total_amount: number
       }

       export interface SubscriptionListItem {
         id: number
         user_id: number
         plan: string
         status: string
         payment_method_id: string | null
         started_at: string
         current_period_start: string
         current_period_end: string
         canceled_at: string | null
         created_at: string
         user_telegram_id: number | null
         user_username: string | null
       }

       export interface SubscriptionListResponse {
         items: SubscriptionListItem[]
         total: number
         page: number
         page_size: number
       }

       export async function getPayments(params: Record<string, any> = {}): Promise<PaymentListResponse> {
         const { data } = await api.get<PaymentListResponse>('/payments', { params })
         return data
       }

       export async function getSubscriptions(params: Record<string, any> = {}): Promise<SubscriptionListResponse> {
         const { data } = await api.get<SubscriptionListResponse>('/subscriptions', { params })
         return data
       }

       export async function updateSubscriptionStatus(id: number, status: string): Promise<void> {
         await api.patch(`/subscriptions/${id}`, { status })
       }
       ```

    2. Create admin-frontend/src/pages/Payments.tsx:
       ```tsx
       import { ProTable, ProColumns } from '@ant-design/pro-components'
       import { Tag, Statistic, Card, Row, Col } from 'antd'
       import dayjs from 'dayjs'
       import { getPayments, PaymentListItem } from '@/api/endpoints/payments'

       const columns: ProColumns<PaymentListItem>[] = [
         { dataIndex: 'id', title: 'ID', copyable: true, width: 100, ellipsis: true },
         {
           dataIndex: 'user_telegram_id',
           title: 'Пользователь',
           render: (_, r) => r.user_username || r.user_telegram_id || '—',
         },
         {
           dataIndex: 'amount',
           title: 'Сумма',
           render: (v) => `${((v as number) / 100).toFixed(0)} RUB`,
           search: false,
         },
         {
           dataIndex: 'status',
           title: 'Статус',
           valueType: 'select',
           valueEnum: {
             pending: { text: 'Ожидает', status: 'Processing' },
             waiting_for_capture: { text: 'Capture', status: 'Warning' },
             succeeded: { text: 'Успешно', status: 'Success' },
             canceled: { text: 'Отменен', status: 'Error' },
           },
           render: (_, r) => {
             const colors: Record<string, string> = {
               pending: 'orange',
               waiting_for_capture: 'blue',
               succeeded: 'green',
               canceled: 'red',
             }
             return <Tag color={colors[r.status]}>{r.status}</Tag>
           },
         },
         {
           dataIndex: 'is_recurring',
           title: 'Автоплатеж',
           render: (v) => v ? 'Да' : 'Нет',
           search: false,
         },
         { dataIndex: 'description', title: 'Описание', ellipsis: true, search: false },
         {
           dataIndex: 'paid_at',
           title: 'Оплачен',
           render: (_, r) => r.paid_at ? dayjs(r.paid_at).format('DD.MM.YYYY HH:mm') : '—',
           search: false,
         },
       ]

       export default function PaymentsPage() {
         return (
           <ProTable<PaymentListItem>
             columns={columns}
             request={async (params) => {
               const { current, pageSize, ...filters } = params
               try {
                 const data = await getPayments({
                   page: current,
                   page_size: pageSize,
                   status: filters.status,
                   user_search: filters.user_telegram_id,
                 })
                 return {
                   data: data.items,
                   total: data.total,
                   success: true,
                 }
               } catch {
                 return { data: [], total: 0, success: false }
               }
             }}
             rowKey="id"
             pagination={{ pageSize: 20 }}
             search={{ filterType: 'light' }}
             headerTitle="Платежи"
           />
         )
       }
       ```

    3. Create admin-frontend/src/pages/Subscriptions.tsx:
       ```tsx
       import { ProTable, ProColumns } from '@ant-design/pro-components'
       import { Tag, Button, Modal, Select, message } from 'antd'
       import { EditOutlined } from '@ant-design/icons'
       import { useState } from 'react'
       import { useMutation, useQueryClient } from '@tanstack/react-query'
       import dayjs from 'dayjs'
       import { getSubscriptions, updateSubscriptionStatus, SubscriptionListItem } from '@/api/endpoints/payments'

       export default function SubscriptionsPage() {
         const [editModal, setEditModal] = useState<{ open: boolean; sub: SubscriptionListItem | null }>({
           open: false,
           sub: null,
         })
         const [newStatus, setNewStatus] = useState('')
         const queryClient = useQueryClient()

         const updateMutation = useMutation({
           mutationFn: ({ id, status }: { id: number; status: string }) =>
             updateSubscriptionStatus(id, status),
           onSuccess: () => {
             message.success('Статус обновлен')
             setEditModal({ open: false, sub: null })
             queryClient.invalidateQueries({ queryKey: ['subscriptions'] })
           },
         })

         const columns: ProColumns<SubscriptionListItem>[] = [
           { dataIndex: 'id', title: 'ID', width: 60 },
           {
             dataIndex: 'user_telegram_id',
             title: 'Пользователь',
             render: (_, r) => r.user_username || r.user_telegram_id || '—',
           },
           {
             dataIndex: 'plan',
             title: 'План',
             valueType: 'select',
             valueEnum: {
               monthly: { text: 'Месяц' },
               yearly: { text: 'Год' },
             },
           },
           {
             dataIndex: 'status',
             title: 'Статус',
             valueType: 'select',
             valueEnum: {
               trial: { text: 'Триал', status: 'Processing' },
               active: { text: 'Активна', status: 'Success' },
               past_due: { text: 'Просрочена', status: 'Warning' },
               canceled: { text: 'Отменена', status: 'Default' },
               expired: { text: 'Истекла', status: 'Error' },
             },
             render: (_, r) => {
               const colors: Record<string, string> = {
                 trial: 'blue',
                 active: 'green',
                 past_due: 'orange',
                 canceled: 'default',
                 expired: 'red',
               }
               return <Tag color={colors[r.status]}>{r.status}</Tag>
             },
           },
           {
             dataIndex: 'current_period_end',
             title: 'Действует до',
             render: (v) => dayjs(v as string).format('DD.MM.YYYY'),
             search: false,
           },
           {
             dataIndex: 'canceled_at',
             title: 'Отменена',
             render: (v) => v ? dayjs(v as string).format('DD.MM.YYYY') : '—',
             search: false,
           },
           {
             dataIndex: 'created_at',
             title: 'Создана',
             render: (v) => dayjs(v as string).format('DD.MM.YYYY'),
             search: false,
           },
           {
             title: 'Действия',
             valueType: 'option',
             render: (_, r) => (
               <Button
                 size="small"
                 icon={<EditOutlined />}
                 onClick={() => {
                   setEditModal({ open: true, sub: r })
                   setNewStatus(r.status)
                 }}
               >
                 Изменить
               </Button>
             ),
           },
         ]

         return (
           <>
             <ProTable<SubscriptionListItem>
               columns={columns}
               request={async (params) => {
                 const { current, pageSize, ...filters } = params
                 try {
                   const data = await getSubscriptions({
                     page: current,
                     page_size: pageSize,
                     status: filters.status,
                     plan: filters.plan,
                     user_search: filters.user_telegram_id,
                   })
                   return {
                     data: data.items,
                     total: data.total,
                     success: true,
                   }
                 } catch {
                   return { data: [], total: 0, success: false }
                 }
               }}
               rowKey="id"
               pagination={{ pageSize: 20 }}
               search={{ filterType: 'light' }}
               headerTitle="Подписки"
             />

             <Modal
               title="Изменить статус подписки"
               open={editModal.open}
               onCancel={() => setEditModal({ open: false, sub: null })}
               onOk={() => {
                 if (editModal.sub) {
                   updateMutation.mutate({ id: editModal.sub.id, status: newStatus })
                 }
               }}
               confirmLoading={updateMutation.isPending}
             >
               <Select
                 value={newStatus}
                 onChange={setNewStatus}
                 style={{ width: '100%' }}
                 options={[
                   { value: 'trial', label: 'Триал' },
                   { value: 'active', label: 'Активна' },
                   { value: 'past_due', label: 'Просрочена' },
                   { value: 'canceled', label: 'Отменена' },
                   { value: 'expired', label: 'Истекла' },
                 ]}
               />
             </Modal>
           </>
         )
       }
       ```

    4. Update routes to import pages:
       ```tsx
       // In admin-frontend/src/routes/index.tsx
       import PaymentsPage from '@/pages/Payments'
       import SubscriptionsPage from '@/pages/Subscriptions'

       // Update children:
       { path: 'subscriptions', element: <SubscriptionsPage /> },
       { path: 'payments', element: <PaymentsPage /> },
       ```
  </action>
  <verify>
    - TypeScript compiles without errors
    - Payments page shows list with filters
    - Subscriptions page shows list with filters
    - Subscription status can be changed
  </verify>
  <done>Payments and subscriptions frontend pages</done>
</task>

</tasks>

<verification>
1. GET /admin/payments returns paginated list
2. GET /admin/subscriptions returns paginated list
3. PATCH /admin/subscriptions/{id} updates status
4. Payments page shows table with filters
5. Subscriptions page shows table with filters
6. Status change modal works
7. User info displayed in tables
</verification>

<success_criteria>
- Payments list with filters (status, user)
- Payment total amount shown
- Subscriptions list with filters (status, plan, user)
- Subscription status can be changed
- User info (telegram_id, username) displayed
</success_criteria>

<output>
After completion, create `.planning/phases/09-admin-panel/09-08-SUMMARY.md`
</output>
