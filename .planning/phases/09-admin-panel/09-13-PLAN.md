---
phase: 09-admin-panel
plan: 13
type: execute
wave: 4
depends_on: ["09-01", "09-06"]
files_modified:
  - src/admin/models.py
  - src/admin/schemas.py
  - src/admin/services/content.py
  - src/admin/router.py
  - alembic/versions/xxx_add_horoscope_content.py
  - admin-frontend/src/pages/Content.tsx
  - admin-frontend/src/api/endpoints/content.ts
  - admin-frontend/src/routes/index.tsx
autonomous: true

must_haves:
  truths:
    - "Admin can view horoscope texts for all 12 zodiac signs"
    - "Admin can edit horoscope text for any zodiac sign"
    - "Changes persist in database"
    - "Content page shows all zodiac signs with current texts"
  artifacts:
    - path: "src/admin/models.py"
      provides: "HoroscopeContent model"
      contains: "class HoroscopeContent"
    - path: "src/admin/services/content.py"
      provides: "Content management service"
      exports: ["get_horoscope_content", "update_horoscope_content"]
    - path: "admin-frontend/src/pages/Content.tsx"
      provides: "Content management page"
  key_links:
    - from: "src/admin/router.py"
      to: "src/admin/services/content.py"
      via: "content endpoints"
      pattern: "get_horoscope_content|update_horoscope_content"
---

<objective>
Create horoscope content management for admin panel.

Purpose: Enable admin to edit horoscope texts for all zodiac signs (ADMIN-08).
Output: Content management API and UI for viewing and editing horoscope texts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-admin-panel/09-CONTEXT.md
@.planning/phases/09-admin-panel/09-RESEARCH.md
@.planning/phases/09-admin-panel/09-01-SUMMARY.md
@.planning/phases/09-admin-panel/09-06-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: HoroscopeContent model and migration</name>
  <files>
    - src/admin/models.py
    - src/admin/schemas.py
    - alembic/versions/xxx_add_horoscope_content.py
  </files>
  <action>
    1. Add HoroscopeContent model to src/admin/models.py:
       ```python
       class HoroscopeContent(Base):
           """Editable horoscope content for each zodiac sign."""
           __tablename__ = "horoscope_content"

           id: Mapped[int] = mapped_column(primary_key=True)

           # Zodiac sign: aries, taurus, gemini, cancer, leo, virgo,
           # libra, scorpio, sagittarius, capricorn, aquarius, pisces
           zodiac_sign: Mapped[str] = mapped_column(String(20), unique=True, index=True)

           # Base horoscope text (admin can edit this)
           # Used as template or additional context for AI generation
           base_text: Mapped[str] = mapped_column(Text, default="")

           # Additional context or notes
           notes: Mapped[str | None] = mapped_column(Text, nullable=True)

           # Last updated
           updated_at: Mapped[datetime] = mapped_column(
               DateTime(timezone=True),
               server_default=func.now(),
               onupdate=func.now(),
           )
           updated_by: Mapped[int | None] = mapped_column(Integer, nullable=True)  # admin id
       ```

    2. Add schemas to src/admin/schemas.py:
       ```python
       class HoroscopeContentItem(BaseModel):
           id: int
           zodiac_sign: str
           base_text: str
           notes: str | None
           updated_at: datetime

           model_config = ConfigDict(from_attributes=True)

       class HoroscopeContentListResponse(BaseModel):
           items: list[HoroscopeContentItem]

       class UpdateHoroscopeContentRequest(BaseModel):
           base_text: str
           notes: str | None = None
       ```

    3. Create migration:
       ```bash
       alembic revision --autogenerate -m "add horoscope_content table"
       ```

    4. Seed initial data in migration (upgrade function):
       ```python
       # After table creation, insert default rows for all 12 signs
       op.execute("""
           INSERT INTO horoscope_content (zodiac_sign, base_text, updated_at)
           VALUES
               ('aries', '', NOW()),
               ('taurus', '', NOW()),
               ('gemini', '', NOW()),
               ('cancer', '', NOW()),
               ('leo', '', NOW()),
               ('virgo', '', NOW()),
               ('libra', '', NOW()),
               ('scorpio', '', NOW()),
               ('sagittarius', '', NOW()),
               ('capricorn', '', NOW()),
               ('aquarius', '', NOW()),
               ('pisces', '', NOW())
           ON CONFLICT (zodiac_sign) DO NOTHING;
       """)
       ```
  </action>
  <verify>
    - alembic upgrade head (exit code 0)
    - psql -c "SELECT COUNT(*) FROM horoscope_content" returns 12
    - All 12 zodiac signs have rows
  </verify>
  <done>HoroscopeContent model and seeded migration</done>
</task>

<task type="auto">
  <name>Task 2: Content service and API endpoints</name>
  <files>
    - src/admin/services/content.py
    - src/admin/router.py
  </files>
  <action>
    1. Create src/admin/services/content.py:
       ```python
       """Content management service for admin panel."""

       from sqlalchemy import select
       from sqlalchemy.ext.asyncio import AsyncSession

       from src.admin.models import HoroscopeContent
       from src.admin.schemas import (
           HoroscopeContentItem, HoroscopeContentListResponse, UpdateHoroscopeContentRequest
       )


       ZODIAC_SIGNS = [
           "aries", "taurus", "gemini", "cancer", "leo", "virgo",
           "libra", "scorpio", "sagittarius", "capricorn", "aquarius", "pisces"
       ]

       ZODIAC_LABELS = {
           "aries": "Овен",
           "taurus": "Телец",
           "gemini": "Близнецы",
           "cancer": "Рак",
           "leo": "Лев",
           "virgo": "Дева",
           "libra": "Весы",
           "scorpio": "Скорпион",
           "sagittarius": "Стрелец",
           "capricorn": "Козерог",
           "aquarius": "Водолей",
           "pisces": "Рыбы",
       }


       async def get_all_horoscope_content(
           session: AsyncSession,
       ) -> HoroscopeContentListResponse:
           """Get horoscope content for all zodiac signs."""
           query = select(HoroscopeContent).order_by(HoroscopeContent.id)
           result = await session.execute(query)
           contents = result.scalars().all()

           # Ensure all signs exist (create missing ones)
           existing_signs = {c.zodiac_sign for c in contents}
           for sign in ZODIAC_SIGNS:
               if sign not in existing_signs:
                   new_content = HoroscopeContent(zodiac_sign=sign, base_text="")
                   session.add(new_content)

           if len(existing_signs) < 12:
               await session.commit()
               # Re-fetch
               result = await session.execute(query)
               contents = result.scalars().all()

           items = [HoroscopeContentItem.model_validate(c) for c in contents]
           return HoroscopeContentListResponse(items=items)


       async def get_horoscope_content(
           session: AsyncSession,
           zodiac_sign: str,
       ) -> HoroscopeContent | None:
           """Get horoscope content for specific zodiac sign."""
           query = select(HoroscopeContent).where(HoroscopeContent.zodiac_sign == zodiac_sign)
           result = await session.execute(query)
           return result.scalar_one_or_none()


       async def update_horoscope_content(
           session: AsyncSession,
           zodiac_sign: str,
           request: UpdateHoroscopeContentRequest,
           admin_id: int,
       ) -> HoroscopeContent | None:
           """Update horoscope content for specific zodiac sign."""
           content = await get_horoscope_content(session, zodiac_sign)
           if not content:
               # Create if doesn't exist
               content = HoroscopeContent(zodiac_sign=zodiac_sign)
               session.add(content)

           content.base_text = request.base_text
           content.notes = request.notes
           content.updated_by = admin_id

           await session.commit()
           await session.refresh(content)
           return content
       ```

    2. Add endpoints to src/admin/router.py:
       ```python
       from src.admin.services.content import (
           get_all_horoscope_content, get_horoscope_content, update_horoscope_content
       )
       from src.admin.schemas import (
           HoroscopeContentItem, HoroscopeContentListResponse, UpdateHoroscopeContentRequest
       )

       @admin_router.get("/content/horoscopes", response_model=HoroscopeContentListResponse)
       async def list_horoscope_content(
           session: AsyncSession = Depends(get_session),
           current_admin: Admin = Depends(get_current_admin),
       ):
           """Get horoscope content for all zodiac signs."""
           return await get_all_horoscope_content(session)

       @admin_router.get("/content/horoscopes/{zodiac_sign}", response_model=HoroscopeContentItem)
       async def get_content_by_sign(
           zodiac_sign: str = Path(...),
           session: AsyncSession = Depends(get_session),
           current_admin: Admin = Depends(get_current_admin),
       ):
           """Get horoscope content for specific zodiac sign."""
           content = await get_horoscope_content(session, zodiac_sign)
           if not content:
               raise HTTPException(status_code=404, detail="Content not found")
           return HoroscopeContentItem.model_validate(content)

       @admin_router.put("/content/horoscopes/{zodiac_sign}", response_model=HoroscopeContentItem)
       async def update_content_by_sign(
           request: UpdateHoroscopeContentRequest,
           zodiac_sign: str = Path(...),
           session: AsyncSession = Depends(get_session),
           current_admin: Admin = Depends(get_current_admin),
       ):
           """Update horoscope content for specific zodiac sign."""
           content = await update_horoscope_content(session, zodiac_sign, request, current_admin.id)
           return HoroscopeContentItem.model_validate(content)
       ```
  </action>
  <verify>
    - Import src.admin.services.content works
    - GET /admin/content/horoscopes returns 12 items
    - PUT /admin/content/horoscopes/aries updates text
  </verify>
  <done>Content service and API endpoints</done>
</task>

<task type="auto">
  <name>Task 3: Content management frontend page</name>
  <files>
    - admin-frontend/src/api/endpoints/content.ts
    - admin-frontend/src/pages/Content.tsx
    - admin-frontend/src/routes/index.tsx
  </files>
  <action>
    1. Create admin-frontend/src/api/endpoints/content.ts:
       ```typescript
       import { api } from '@/api/client'

       export interface HoroscopeContentItem {
         id: number
         zodiac_sign: string
         base_text: string
         notes: string | null
         updated_at: string
       }

       export interface HoroscopeContentListResponse {
         items: HoroscopeContentItem[]
       }

       export interface UpdateHoroscopeContentRequest {
         base_text: string
         notes?: string | null
       }

       export async function getHoroscopeContent(): Promise<HoroscopeContentListResponse> {
         const { data } = await api.get<HoroscopeContentListResponse>('/content/horoscopes')
         return data
       }

       export async function updateHoroscopeContent(
         zodiacSign: string,
         request: UpdateHoroscopeContentRequest
       ): Promise<HoroscopeContentItem> {
         const { data } = await api.put<HoroscopeContentItem>(
           `/content/horoscopes/${zodiacSign}`,
           request
         )
         return data
       }
       ```

    2. Create admin-frontend/src/pages/Content.tsx:
       ```tsx
       import { useState } from 'react'
       import {
         Card, Table, Button, Modal, Form, Input, message, Tag, Typography
       } from 'antd'
       import { EditOutlined, SaveOutlined } from '@ant-design/icons'
       import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
       import dayjs from 'dayjs'
       import {
         getHoroscopeContent, updateHoroscopeContent, HoroscopeContentItem
       } from '@/api/endpoints/content'

       const ZODIAC_LABELS: Record<string, string> = {
         aries: 'Овен',
         taurus: 'Телец',
         gemini: 'Близнецы',
         cancer: 'Рак',
         leo: 'Лев',
         virgo: 'Дева',
         libra: 'Весы',
         scorpio: 'Скорпион',
         sagittarius: 'Стрелец',
         capricorn: 'Козерог',
         aquarius: 'Водолей',
         pisces: 'Рыбы',
       }

       const ZODIAC_EMOJI: Record<string, string> = {
         aries: '♈',
         taurus: '♉',
         gemini: '♊',
         cancer: '♋',
         leo: '♌',
         virgo: '♍',
         libra: '♎',
         scorpio: '♏',
         sagittarius: '♐',
         capricorn: '♑',
         aquarius: '♒',
         pisces: '♓',
       }

       export default function ContentPage() {
         const [editModal, setEditModal] = useState<{ open: boolean; item: HoroscopeContentItem | null }>({
           open: false,
           item: null,
         })
         const [form] = Form.useForm()
         const queryClient = useQueryClient()

         const { data, isLoading } = useQuery({
           queryKey: ['horoscope-content'],
           queryFn: getHoroscopeContent,
         })

         const updateMutation = useMutation({
           mutationFn: ({ zodiacSign, request }: { zodiacSign: string; request: { base_text: string; notes?: string } }) =>
             updateHoroscopeContent(zodiacSign, request),
           onSuccess: () => {
             message.success('Контент сохранен')
             setEditModal({ open: false, item: null })
             queryClient.invalidateQueries({ queryKey: ['horoscope-content'] })
           },
           onError: () => message.error('Ошибка сохранения'),
         })

         const openEditModal = (item: HoroscopeContentItem) => {
           setEditModal({ open: true, item })
           form.setFieldsValue({
             base_text: item.base_text,
             notes: item.notes,
           })
         }

         const handleSave = () => {
           form.validateFields().then((values) => {
             if (editModal.item) {
               updateMutation.mutate({
                 zodiacSign: editModal.item.zodiac_sign,
                 request: values,
               })
             }
           })
         }

         const columns = [
           {
             title: 'Знак',
             key: 'zodiac',
             width: 150,
             render: (_: any, r: HoroscopeContentItem) => (
               <span>
                 {ZODIAC_EMOJI[r.zodiac_sign]} {ZODIAC_LABELS[r.zodiac_sign] || r.zodiac_sign}
               </span>
             ),
           },
           {
             title: 'Текст',
             dataIndex: 'base_text',
             ellipsis: true,
             render: (v: string) => v ? (
               <Typography.Text ellipsis style={{ maxWidth: 400 }}>{v}</Typography.Text>
             ) : (
               <Tag color="default">Пусто</Tag>
             ),
           },
           {
             title: 'Обновлено',
             dataIndex: 'updated_at',
             width: 150,
             render: (v: string) => dayjs(v).format('DD.MM.YYYY HH:mm'),
           },
           {
             title: 'Действия',
             key: 'actions',
             width: 100,
             render: (_: any, r: HoroscopeContentItem) => (
               <Button
                 type="primary"
                 size="small"
                 icon={<EditOutlined />}
                 onClick={() => openEditModal(r)}
               >
                 Редактировать
               </Button>
             ),
           },
         ]

         return (
           <>
             <Card title="Контент гороскопов">
               <Typography.Paragraph type="secondary" style={{ marginBottom: 16 }}>
                 Редактируйте базовые тексты гороскопов для каждого знака зодиака.
                 Эти тексты используются как дополнительный контекст для AI генерации.
               </Typography.Paragraph>

               <Table
                 dataSource={data?.items}
                 columns={columns}
                 rowKey="id"
                 loading={isLoading}
                 pagination={false}
               />
             </Card>

             <Modal
               title={
                 editModal.item
                   ? `Редактировать: ${ZODIAC_EMOJI[editModal.item.zodiac_sign]} ${ZODIAC_LABELS[editModal.item.zodiac_sign]}`
                   : 'Редактировать'
               }
               open={editModal.open}
               onCancel={() => setEditModal({ open: false, item: null })}
               onOk={handleSave}
               okText="Сохранить"
               okButtonProps={{ icon: <SaveOutlined />, loading: updateMutation.isPending }}
               width={700}
             >
               <Form form={form} layout="vertical">
                 <Form.Item
                   name="base_text"
                   label="Базовый текст гороскопа"
                   rules={[{ max: 5000, message: 'Максимум 5000 символов' }]}
                 >
                   <Input.TextArea
                     rows={10}
                     placeholder="Введите базовый текст гороскопа для этого знака..."
                     showCount
                     maxLength={5000}
                   />
                 </Form.Item>

                 <Form.Item
                   name="notes"
                   label="Заметки (видны только админам)"
                 >
                   <Input.TextArea
                     rows={3}
                     placeholder="Внутренние заметки..."
                   />
                 </Form.Item>
               </Form>
             </Modal>
           </>
         )
       }
       ```

    3. Update routes in admin-frontend/src/routes/index.tsx:
       ```tsx
       import ContentPage from '@/pages/Content'

       // Add to children:
       { path: 'content', element: <ContentPage /> },
       ```
  </action>
  <verify>
    - App starts without errors
    - Content page renders with 12 zodiac signs
    - Edit modal opens and shows current text
    - Save updates the content
    - Changes persist after page refresh
  </verify>
  <done>Content management frontend page complete</done>
</task>

</tasks>

<verification>
1. HoroscopeContent table exists with 12 rows
2. GET /admin/content/horoscopes returns all 12 signs
3. PUT /admin/content/horoscopes/{sign} updates text
4. Frontend Content page shows all signs
5. Edit modal allows text editing
6. Changes persist in database
7. Mobile responsive (text wraps properly)
</verification>

<success_criteria>
- Admin can view horoscope texts for all 12 zodiac signs
- Admin can edit text for any sign via modal
- Text changes persist after save
- UI shows last update time
- Notes field for admin-only info
</success_criteria>

<output>
After completion, create `.planning/phases/09-admin-panel/09-13-SUMMARY.md`
</output>
