---
phase: 09-admin-panel
plan: 07
type: execute
wave: 4
depends_on: ["09-01", "09-04"]
files_modified:
  - src/admin/services/messaging.py
  - src/admin/models.py
  - src/admin/router.py
  - src/admin/schemas.py
  - alembic/versions/xxx_add_scheduled_messages.py
  - admin-frontend/src/pages/Messages.tsx
  - admin-frontend/src/api/endpoints/messages.ts
autonomous: true

must_haves:
  truths:
    - "Admin can send message to single user via Telegram"
    - "Admin can send broadcast to filtered segment"
    - "Admin can schedule message for future delivery"
    - "Message history shows delivery stats"
  artifacts:
    - path: "src/admin/services/messaging.py"
      provides: "Messaging service with send and broadcast"
      exports: ["send_message_to_user", "broadcast_message", "schedule_message"]
    - path: "src/admin/models.py"
      provides: "ScheduledMessage model"
      contains: "class ScheduledMessage"
    - path: "admin-frontend/src/pages/Messages.tsx"
      provides: "Messages management page"
  key_links:
    - from: "src/admin/services/messaging.py"
      to: "src/bot/bot.py"
      via: "get_bot() for sending (requires bot initialized via FastAPI lifespan)"
      pattern: "get_bot.*send_message"
    - from: "src/admin/services/messaging.py"
      to: "src/main.py"
      via: "depends on FastAPI lifespan calling init_bot()"
      pattern: "init_bot|lifespan"
---

<objective>
Create messaging system for sending messages to users and segments.

Purpose: Enable admin to communicate with users directly and via broadcasts.
Output: Messaging API and UI with send, broadcast, and scheduling capabilities.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-admin-panel/09-CONTEXT.md
@.planning/phases/09-admin-panel/09-RESEARCH.md
@.planning/phases/09-admin-panel/09-01-SUMMARY.md
@.planning/phases/09-admin-panel/09-04-SUMMARY.md
@src/bot/bot.py
@src/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: ScheduledMessage model and schemas</name>
  <files>
    - src/admin/models.py
    - src/admin/schemas.py
    - alembic/versions/xxx_add_scheduled_messages.py
  </files>
  <action>
    1. Add ScheduledMessage model to src/admin/models.py:
       ```python
       from datetime import datetime
       from sqlalchemy import Boolean, DateTime, Integer, String, Text, JSON, func
       from sqlalchemy.orm import Mapped, mapped_column
       from src.db.models.base import Base

       # Keep existing Admin model, add ScheduledMessage:

       class ScheduledMessage(Base):
           """Scheduled or sent broadcast messages."""
           __tablename__ = "scheduled_messages"

           id: Mapped[int] = mapped_column(primary_key=True)

           # Message content
           text: Mapped[str] = mapped_column(Text)

           # Target filters (JSON): {"is_premium": true, "zodiac_sign": "aries"}
           # Empty dict = all users
           filters: Mapped[dict] = mapped_column(JSON, default=dict)

           # Single user target (if not broadcast)
           target_user_id: Mapped[int | None] = mapped_column(Integer, nullable=True)

           # Scheduling
           scheduled_at: Mapped[datetime | None] = mapped_column(
               DateTime(timezone=True), nullable=True
           )  # None = send immediately
           sent_at: Mapped[datetime | None] = mapped_column(
               DateTime(timezone=True), nullable=True
           )

           # Stats
           total_recipients: Mapped[int] = mapped_column(Integer, default=0)
           delivered_count: Mapped[int] = mapped_column(Integer, default=0)
           failed_count: Mapped[int] = mapped_column(Integer, default=0)

           # Status: pending, sending, sent, canceled
           status: Mapped[str] = mapped_column(String(20), default="pending")

           created_at: Mapped[datetime] = mapped_column(
               DateTime(timezone=True),
               server_default=func.now(),
           )
           created_by: Mapped[int | None] = mapped_column(Integer, nullable=True)  # admin id
       ```

    2. Add messaging schemas to src/admin/schemas.py:
       ```python
       class SendMessageRequest(BaseModel):
           text: str
           target_user_id: int | None = None  # For single user
           filters: dict | None = None  # For broadcast: {"is_premium": true, "zodiac_sign": "aries"}
           scheduled_at: datetime | None = None  # For scheduling

       class MessageHistoryItem(BaseModel):
           id: int
           text: str
           filters: dict
           target_user_id: int | None
           scheduled_at: datetime | None
           sent_at: datetime | None
           total_recipients: int
           delivered_count: int
           failed_count: int
           status: str
           created_at: datetime

           model_config = ConfigDict(from_attributes=True)

       class MessageHistoryResponse(BaseModel):
           items: list[MessageHistoryItem]
           total: int
           page: int
           page_size: int

       class SendMessageResponse(BaseModel):
           message_id: int
           status: str
           recipients_count: int
       ```

    3. Create migration:
       ```bash
       alembic revision --autogenerate -m "add scheduled_messages table"
       ```
  </action>
  <verify>
    - alembic upgrade head succeeds
    - Table "scheduled_messages" exists
  </verify>
  <done>ScheduledMessage model and migration created</done>
</task>

<task type="auto">
  <name>Task 2: Messaging service</name>
  <files>
    - src/admin/services/messaging.py
  </files>
  <action>
    Create src/admin/services/messaging.py:
    ```python
    """Messaging service for admin panel."""

    import asyncio
    from datetime import datetime, timezone
    from typing import Any

    import structlog
    from sqlalchemy import select, func
    from sqlalchemy.ext.asyncio import AsyncSession

    from src.bot.bot import get_bot
    from src.db.models.user import User
    from src.admin.models import ScheduledMessage
    from src.admin.schemas import (
        SendMessageRequest, MessageHistoryItem, MessageHistoryResponse, SendMessageResponse
    )

    logger = structlog.get_logger()


    async def send_message_to_user(telegram_id: int, text: str) -> bool:
        """Send message to single user via Telegram bot.

        IMPORTANT: get_bot() requires the bot to be initialized.
        In FastAPI context, this is handled by the lifespan manager in src/main.py
        which calls init_bot() on startup. If running outside FastAPI (e.g., tests),
        ensure init_bot() is called first.
        """
        try:
            bot = get_bot()
            if bot is None:
                await logger.aerror(
                    "Bot not initialized. Ensure FastAPI lifespan has started or call init_bot() first.",
                    telegram_id=telegram_id,
                )
                return False
            await bot.send_message(chat_id=telegram_id, text=text)
            return True
        except Exception as e:
            await logger.awarning(
                "Failed to send message to user",
                telegram_id=telegram_id,
                error=str(e),
            )
            return False


    def build_user_query(filters: dict[str, Any]):
        """Build SQLAlchemy query from filters dict."""
        query = select(User.telegram_id)

        if filters.get("is_premium") is not None:
            query = query.where(User.is_premium == filters["is_premium"])

        if filters.get("zodiac_sign"):
            query = query.where(User.zodiac_sign == filters["zodiac_sign"])

        if filters.get("has_detailed_natal") is not None:
            if filters["has_detailed_natal"]:
                query = query.where(User.detailed_natal_purchased_at.isnot(None))
            else:
                query = query.where(User.detailed_natal_purchased_at.is_(None))

        if filters.get("notifications_enabled") is not None:
            query = query.where(User.notifications_enabled == filters["notifications_enabled"])

        return query


    async def broadcast_message(
        session: AsyncSession,
        text: str,
        filters: dict[str, Any],
        admin_id: int,
    ) -> tuple[int, int, int]:
        """
        Send message to all users matching filters.

        Returns: (total, delivered, failed)
        """
        query = build_user_query(filters)
        result = await session.execute(query)
        telegram_ids = [row[0] for row in result.fetchall()]

        total = len(telegram_ids)
        delivered = 0
        failed = 0

        # Telegram rate limit: ~30 msg/sec for bots
        # Send in batches with delay
        batch_size = 25
        delay_between_batches = 1.0  # seconds

        for i in range(0, total, batch_size):
            batch = telegram_ids[i:i + batch_size]
            tasks = [send_message_to_user(tid, text) for tid in batch]
            results = await asyncio.gather(*tasks)

            delivered += sum(1 for r in results if r)
            failed += sum(1 for r in results if not r)

            if i + batch_size < total:
                await asyncio.sleep(delay_between_batches)

        return total, delivered, failed


    async def send_or_schedule_message(
        session: AsyncSession,
        request: SendMessageRequest,
        admin_id: int,
    ) -> SendMessageResponse:
        """Send message immediately or schedule for later."""

        # Create message record
        message = ScheduledMessage(
            text=request.text,
            filters=request.filters or {},
            target_user_id=request.target_user_id,
            scheduled_at=request.scheduled_at,
            status="pending",
            created_by=admin_id,
        )
        session.add(message)
        await session.flush()

        # If scheduled for later, just save and return
        if request.scheduled_at and request.scheduled_at > datetime.now(timezone.utc):
            await session.commit()
            return SendMessageResponse(
                message_id=message.id,
                status="scheduled",
                recipients_count=0,
            )

        # Send immediately
        message.status = "sending"
        await session.commit()

        if request.target_user_id:
            # Single user
            user = await session.scalar(
                select(User).where(User.id == request.target_user_id)
            )
            if user:
                success = await send_message_to_user(user.telegram_id, request.text)
                message.total_recipients = 1
                message.delivered_count = 1 if success else 0
                message.failed_count = 0 if success else 1
            else:
                message.total_recipients = 0
                message.delivered_count = 0
                message.failed_count = 0
        else:
            # Broadcast
            total, delivered, failed = await broadcast_message(
                session, request.text, request.filters or {}, admin_id
            )
            message.total_recipients = total
            message.delivered_count = delivered
            message.failed_count = failed

        message.status = "sent"
        message.sent_at = datetime.now(timezone.utc)
        await session.commit()

        return SendMessageResponse(
            message_id=message.id,
            status="sent",
            recipients_count=message.delivered_count,
        )


    async def get_message_history(
        session: AsyncSession,
        page: int = 1,
        page_size: int = 20,
    ) -> MessageHistoryResponse:
        """Get message history with pagination."""
        query = select(ScheduledMessage).order_by(ScheduledMessage.created_at.desc())

        # Count total
        count_query = select(func.count()).select_from(ScheduledMessage)
        total = await session.scalar(count_query) or 0

        # Paginate
        query = query.offset((page - 1) * page_size).limit(page_size)
        result = await session.execute(query)
        messages = result.scalars().all()

        items = [MessageHistoryItem.model_validate(m) for m in messages]

        return MessageHistoryResponse(
            items=items,
            total=total,
            page=page,
            page_size=page_size,
        )


    async def cancel_scheduled_message(
        session: AsyncSession,
        message_id: int,
    ) -> bool:
        """Cancel a scheduled message (if not yet sent)."""
        message = await session.get(ScheduledMessage, message_id)
        if not message or message.status != "pending":
            return False

        message.status = "canceled"
        await session.commit()
        return True
    ```
  </action>
  <verify>
    - Import src.admin.services.messaging works
    - Functions have correct signatures
    - send_message_to_user checks get_bot() is not None
    - Code documents dependency on FastAPI lifespan (init_bot)
    - Manual test: Start app, send test message to known telegram_id, verify delivery in Telegram
  </verify>
  <done>Messaging service with send, broadcast, and scheduling</done>
</task>

<task type="auto">
  <name>Task 3: Messaging API endpoints and frontend</name>
  <files>
    - src/admin/router.py
    - admin-frontend/src/api/endpoints/messages.ts
    - admin-frontend/src/pages/Messages.tsx
    - admin-frontend/src/routes/index.tsx
  </files>
  <action>
    1. Add messaging endpoints to src/admin/router.py:
       ```python
       from src.admin.services.messaging import (
           send_or_schedule_message, get_message_history, cancel_scheduled_message
       )
       from src.admin.schemas import (
           SendMessageRequest, SendMessageResponse, MessageHistoryResponse
       )

       @admin_router.post("/messages", response_model=SendMessageResponse)
       async def send_message(
           request: SendMessageRequest,
           session: AsyncSession = Depends(get_session),
           current_admin: Admin = Depends(get_current_admin),
       ):
           """Send or schedule a message."""
           return await send_or_schedule_message(session, request, current_admin.id)

       @admin_router.get("/messages", response_model=MessageHistoryResponse)
       async def messages_history(
           page: int = Query(1, ge=1),
           page_size: int = Query(20, ge=1, le=100),
           session: AsyncSession = Depends(get_session),
           current_admin: Admin = Depends(get_current_admin),
       ):
           """Get message history."""
           return await get_message_history(session, page, page_size)

       @admin_router.delete("/messages/{message_id}")
       async def cancel_message(
           message_id: int = Path(...),
           session: AsyncSession = Depends(get_session),
           current_admin: Admin = Depends(get_current_admin),
       ):
           """Cancel a scheduled message."""
           success = await cancel_scheduled_message(session, message_id)
           if not success:
               raise HTTPException(status_code=400, detail="Cannot cancel message")
           return {"status": "canceled"}
       ```

    2. Create admin-frontend/src/api/endpoints/messages.ts:
       ```typescript
       import { api } from '@/api/client'

       export interface SendMessageRequest {
         text: string
         target_user_id?: number
         filters?: Record<string, any>
         scheduled_at?: string
       }

       export interface SendMessageResponse {
         message_id: number
         status: string
         recipients_count: number
       }

       export interface MessageHistoryItem {
         id: number
         text: string
         filters: Record<string, any>
         target_user_id: number | null
         scheduled_at: string | null
         sent_at: string | null
         total_recipients: number
         delivered_count: number
         failed_count: number
         status: string
         created_at: string
       }

       export interface MessageHistoryResponse {
         items: MessageHistoryItem[]
         total: number
         page: number
         page_size: number
       }

       export async function sendMessage(request: SendMessageRequest): Promise<SendMessageResponse> {
         const { data } = await api.post<SendMessageResponse>('/messages', request)
         return data
       }

       export async function getMessageHistory(page = 1, pageSize = 20): Promise<MessageHistoryResponse> {
         const { data } = await api.get<MessageHistoryResponse>('/messages', {
           params: { page, page_size: pageSize },
         })
         return data
       }

       export async function cancelMessage(messageId: number): Promise<void> {
         await api.delete(`/messages/${messageId}`)
       }
       ```

    3. Create admin-frontend/src/pages/Messages.tsx:
       ```tsx
       import { useState } from 'react'
       import {
         Card, Form, Input, Button, Select, DatePicker, Table, Tag,
         Space, message, Typography, Row, Col, Switch, Divider
       } from 'antd'
       import { SendOutlined, ClockCircleOutlined, DeleteOutlined } from '@ant-design/icons'
       import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
       import dayjs from 'dayjs'
       import { sendMessage, getMessageHistory, cancelMessage, MessageHistoryItem } from '@/api/endpoints/messages'

       const ZODIAC_OPTIONS = [
         { value: 'aries', label: 'Овен' },
         { value: 'taurus', label: 'Телец' },
         { value: 'gemini', label: 'Близнецы' },
         { value: 'cancer', label: 'Рак' },
         { value: 'leo', label: 'Лев' },
         { value: 'virgo', label: 'Дева' },
         { value: 'libra', label: 'Весы' },
         { value: 'scorpio', label: 'Скорпион' },
         { value: 'sagittarius', label: 'Стрелец' },
         { value: 'capricorn', label: 'Козерог' },
         { value: 'aquarius', label: 'Водолей' },
         { value: 'pisces', label: 'Рыбы' },
       ]

       export default function MessagesPage() {
         const [form] = Form.useForm()
         const [isBroadcast, setIsBroadcast] = useState(true)
         const [isScheduled, setIsScheduled] = useState(false)
         const queryClient = useQueryClient()

         const { data: history, isLoading } = useQuery({
           queryKey: ['messages'],
           queryFn: () => getMessageHistory(),
         })

         const sendMutation = useMutation({
           mutationFn: sendMessage,
           onSuccess: (result) => {
             message.success(
               result.status === 'scheduled'
                 ? 'Сообщение запланировано'
                 : `Доставлено: ${result.recipients_count}`
             )
             form.resetFields()
             queryClient.invalidateQueries({ queryKey: ['messages'] })
           },
           onError: () => message.error('Ошибка отправки'),
         })

         const cancelMutation = useMutation({
           mutationFn: cancelMessage,
           onSuccess: () => {
             message.success('Отменено')
             queryClient.invalidateQueries({ queryKey: ['messages'] })
           },
         })

         const onFinish = (values: any) => {
           const request: any = { text: values.text }

           if (!isBroadcast && values.target_user_id) {
             request.target_user_id = values.target_user_id
           } else {
             const filters: any = {}
             if (values.is_premium !== undefined) filters.is_premium = values.is_premium
             if (values.zodiac_sign) filters.zodiac_sign = values.zodiac_sign
             request.filters = filters
           }

           if (isScheduled && values.scheduled_at) {
             request.scheduled_at = values.scheduled_at.toISOString()
           }

           sendMutation.mutate(request)
         }

         const columns = [
           {
             title: 'Текст',
             dataIndex: 'text',
             ellipsis: true,
             width: 200,
           },
           {
             title: 'Получатели',
             key: 'recipients',
             render: (_: any, r: MessageHistoryItem) => (
               <span>
                 {r.target_user_id ? `User #${r.target_user_id}` : 'Рассылка'}
                 {' '}<Tag>{r.delivered_count}/{r.total_recipients}</Tag>
               </span>
             ),
           },
           {
             title: 'Статус',
             dataIndex: 'status',
             render: (v: string) => {
               const colors: Record<string, string> = {
                 sent: 'green',
                 pending: 'orange',
                 sending: 'blue',
                 canceled: 'red',
               }
               return <Tag color={colors[v]}>{v}</Tag>
             },
           },
           {
             title: 'Дата',
             key: 'date',
             render: (_: any, r: MessageHistoryItem) =>
               dayjs(r.sent_at || r.scheduled_at || r.created_at).format('DD.MM.YYYY HH:mm'),
           },
           {
             title: 'Действия',
             key: 'actions',
             render: (_: any, r: MessageHistoryItem) =>
               r.status === 'pending' && (
                 <Button
                   size="small"
                   danger
                   icon={<DeleteOutlined />}
                   onClick={() => cancelMutation.mutate(r.id)}
                 />
               ),
           },
         ]

         return (
           <Row gutter={[16, 16]}>
             <Col xs={24} lg={10}>
               <Card title="Отправить сообщение">
                 <Form form={form} layout="vertical" onFinish={onFinish}>
                   <Form.Item
                     name="text"
                     label="Текст сообщения"
                     rules={[{ required: true, message: 'Введите текст' }]}
                   >
                     <Input.TextArea rows={4} placeholder="Текст сообщения..." />
                   </Form.Item>

                   <Space style={{ marginBottom: 16 }}>
                     <Switch
                       checked={isBroadcast}
                       onChange={setIsBroadcast}
                       checkedChildren="Рассылка"
                       unCheckedChildren="Одному"
                     />
                     <Switch
                       checked={isScheduled}
                       onChange={setIsScheduled}
                       checkedChildren="Отложить"
                       unCheckedChildren="Сейчас"
                     />
                   </Space>

                   {!isBroadcast ? (
                     <Form.Item
                       name="target_user_id"
                       label="ID пользователя"
                       rules={[{ required: true, message: 'Укажите ID' }]}
                     >
                       <Input type="number" placeholder="User ID" />
                     </Form.Item>
                   ) : (
                     <>
                       <Form.Item name="is_premium" label="Статус">
                         <Select allowClear placeholder="Все">
                           <Select.Option value={true}>Premium</Select.Option>
                           <Select.Option value={false}>Free</Select.Option>
                         </Select>
                       </Form.Item>
                       <Form.Item name="zodiac_sign" label="Знак зодиака">
                         <Select allowClear placeholder="Все" options={ZODIAC_OPTIONS} />
                       </Form.Item>
                     </>
                   )}

                   {isScheduled && (
                     <Form.Item
                       name="scheduled_at"
                       label="Дата и время"
                       rules={[{ required: true, message: 'Выберите время' }]}
                     >
                       <DatePicker
                         showTime
                         format="DD.MM.YYYY HH:mm"
                         style={{ width: '100%' }}
                       />
                     </Form.Item>
                   )}

                   <Button
                     type="primary"
                     htmlType="submit"
                     icon={isScheduled ? <ClockCircleOutlined /> : <SendOutlined />}
                     loading={sendMutation.isPending}
                     block
                   >
                     {isScheduled ? 'Запланировать' : 'Отправить'}
                   </Button>
                 </Form>
               </Card>
             </Col>

             <Col xs={24} lg={14}>
               <Card title="История сообщений">
                 <Table
                   dataSource={history?.items}
                   columns={columns}
                   rowKey="id"
                   loading={isLoading}
                   pagination={{
                     total: history?.total,
                     pageSize: 20,
                   }}
                   size="small"
                 />
               </Card>
             </Col>
           </Row>
         )
       }
       ```

    4. Update routes to import MessagesPage:
       ```tsx
       // In admin-frontend/src/routes/index.tsx
       import MessagesPage from '@/pages/Messages'

       // Update children:
       { path: 'messages', element: <MessagesPage /> },
       ```
  </action>
  <verify>
    - App starts without errors
    - POST /admin/messages works
    - GET /admin/messages returns history
    - Frontend Messages page renders
    - Can send message to single user
    - Can send broadcast
    - Can schedule message
    - Can cancel pending message
  </verify>
  <done>Messaging API endpoints and frontend page complete</done>
</task>

</tasks>

<verification>
1. ScheduledMessage table exists in database
2. POST /admin/messages sends to single user
3. POST /admin/messages sends broadcast to filtered segment
4. POST /admin/messages schedules for future
5. GET /admin/messages returns history with stats
6. DELETE /admin/messages/{id} cancels pending message
7. Frontend shows send form with filters
8. Frontend shows history table with status
9. **CRITICAL**: Message actually sends via Telegram - get_bot() returns valid bot initialized via FastAPI lifespan
10. **CRITICAL**: Send test message from admin panel and verify it arrives in Telegram
</verification>

<success_criteria>
- Send message to single user (by ID)
- Broadcast to segment (premium, zodiac, etc.)
- Schedule message for future delivery
- Message history with delivery stats
- Cancel scheduled messages
- Rate-limited sending (25 msg/sec)
</success_criteria>

<output>
After completion, create `.planning/phases/09-admin-panel/09-07-SUMMARY.md`
</output>
