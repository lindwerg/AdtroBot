---
phase: 09-admin-panel
plan: 04
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/admin/services/users.py
  - src/admin/router.py
  - src/admin/schemas.py
autonomous: true

must_haves:
  truths:
    - "GET /admin/users returns paginated list with filters"
    - "GET /admin/users/{id} returns full user profile with history"
    - "PATCH /admin/users/{id}/subscription can activate/cancel premium"
    - "POST /admin/users/{id}/gift can give credits/premium"
  artifacts:
    - path: "src/admin/services/users.py"
      provides: "User CRUD operations"
      exports: ["list_users", "get_user_detail", "update_subscription", "gift_to_user"]
    - path: "src/admin/schemas.py"
      provides: "User list and detail schemas"
      contains: "UserListItem"
  key_links:
    - from: "src/admin/router.py"
      to: "src/admin/services/users.py"
      via: "endpoint calls"
      pattern: "list_users|get_user_detail"
---

<objective>
Create user management API with list, search, filters, pagination, and actions.

Purpose: Enable admin to view, search, filter users and manage their subscriptions/credits.
Output: Complete user management API with CRUD and bulk operations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-admin-panel/09-CONTEXT.md
@.planning/phases/09-admin-panel/09-RESEARCH.md
@.planning/phases/09-admin-panel/09-01-SUMMARY.md
@src/db/models/user.py
@src/db/models/payment.py
@src/db/models/subscription.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: User schemas</name>
  <files>
    - src/admin/schemas.py
  </files>
  <action>
    Add user management schemas to src/admin/schemas.py:

    ```python
    from datetime import datetime, date
    from pydantic import BaseModel, ConfigDict
    from typing import Literal

    class UserListItem(BaseModel):
        id: int
        telegram_id: int
        username: str | None
        zodiac_sign: str | None
        is_premium: bool
        premium_until: datetime | None
        created_at: datetime
        tarot_spread_count: int
        daily_spread_limit: int
        detailed_natal_purchased_at: datetime | None

        model_config = ConfigDict(from_attributes=True)

    class UserListResponse(BaseModel):
        items: list[UserListItem]
        total: int
        page: int
        page_size: int
        pages: int

    class PaymentHistoryItem(BaseModel):
        id: str
        amount: int  # kopeks
        status: str
        description: str | None
        created_at: datetime
        paid_at: datetime | None

        model_config = ConfigDict(from_attributes=True)

    class SubscriptionInfo(BaseModel):
        id: int
        plan: str
        status: str
        started_at: datetime
        current_period_end: datetime
        canceled_at: datetime | None

        model_config = ConfigDict(from_attributes=True)

    class TarotSpreadHistoryItem(BaseModel):
        id: int
        spread_type: str
        question: str
        created_at: datetime

        model_config = ConfigDict(from_attributes=True)

    class UserDetail(BaseModel):
        id: int
        telegram_id: int
        username: str | None
        birth_date: date | None
        zodiac_sign: str | None
        birth_time: str | None  # HH:MM format
        birth_city: str | None
        timezone: str | None
        notifications_enabled: bool
        notification_hour: int | None
        is_premium: bool
        premium_until: datetime | None
        daily_spread_limit: int
        tarot_spread_count: int
        detailed_natal_purchased_at: datetime | None
        created_at: datetime

        subscription: SubscriptionInfo | None
        payments: list[PaymentHistoryItem]
        recent_spreads: list[TarotSpreadHistoryItem]

        model_config = ConfigDict(from_attributes=True)

    class UpdateSubscriptionRequest(BaseModel):
        action: Literal["activate", "cancel", "extend"]
        days: int | None = None  # For extend action

    class GiftRequest(BaseModel):
        gift_type: Literal["premium_days", "detailed_natal", "tarot_spreads"]
        value: int  # days for premium, count for spreads

    class BulkActionRequest(BaseModel):
        user_ids: list[int]
        action: Literal["activate_premium", "cancel_premium", "ban", "unban", "gift_spreads"]
        value: int | None = None  # For gift_spreads

    class BulkActionResponse(BaseModel):
        success_count: int
        failed_count: int
        errors: list[str]
    ```
  </action>
  <verify>
    - Import src.admin.schemas works
    - All schemas can be instantiated
  </verify>
  <done>User management schemas defined</done>
</task>

<task type="auto">
  <name>Task 2: User service</name>
  <files>
    - src/admin/services/users.py
  </files>
  <action>
    Create src/admin/services/users.py:

    ```python
    """User management service."""

    from datetime import datetime, timedelta, timezone
    from sqlalchemy import select, func, or_, and_
    from sqlalchemy.ext.asyncio import AsyncSession

    from src.db.models.user import User
    from src.db.models.payment import Payment
    from src.db.models.subscription import Subscription, SubscriptionStatus
    from src.db.models.tarot_spread import TarotSpread
    from src.admin.schemas import (
        UserListItem, UserListResponse, UserDetail,
        PaymentHistoryItem, SubscriptionInfo, TarotSpreadHistoryItem,
        UpdateSubscriptionRequest, GiftRequest, BulkActionRequest, BulkActionResponse
    )


    async def list_users(
        session: AsyncSession,
        page: int = 1,
        page_size: int = 20,
        search: str | None = None,
        zodiac_sign: str | None = None,
        is_premium: bool | None = None,
        has_detailed_natal: bool | None = None,
        sort_by: str = "created_at",
        sort_order: str = "desc",
    ) -> UserListResponse:
        """List users with filters and pagination."""
        query = select(User)

        # Search filter (telegram_id or username)
        if search:
            if search.isdigit():
                query = query.where(User.telegram_id == int(search))
            else:
                query = query.where(User.username.ilike(f"%{search}%"))

        # Zodiac filter
        if zodiac_sign:
            query = query.where(User.zodiac_sign == zodiac_sign)

        # Premium filter
        if is_premium is not None:
            query = query.where(User.is_premium == is_premium)

        # Detailed natal filter
        if has_detailed_natal is not None:
            if has_detailed_natal:
                query = query.where(User.detailed_natal_purchased_at.isnot(None))
            else:
                query = query.where(User.detailed_natal_purchased_at.is_(None))

        # Count total
        count_query = select(func.count()).select_from(query.subquery())
        total = await session.scalar(count_query) or 0

        # Sort
        sort_column = getattr(User, sort_by, User.created_at)
        if sort_order == "desc":
            query = query.order_by(sort_column.desc())
        else:
            query = query.order_by(sort_column.asc())

        # Pagination
        query = query.offset((page - 1) * page_size).limit(page_size)

        result = await session.execute(query)
        users = result.scalars().all()

        items = [UserListItem.model_validate(u) for u in users]

        return UserListResponse(
            items=items,
            total=total,
            page=page,
            page_size=page_size,
            pages=(total + page_size - 1) // page_size,
        )


    async def get_user_detail(session: AsyncSession, user_id: int) -> UserDetail | None:
        """Get detailed user info including history."""
        result = await session.execute(
            select(User).where(User.id == user_id)
        )
        user = result.scalar_one_or_none()
        if not user:
            return None

        # Get subscription
        sub_result = await session.execute(
            select(Subscription)
            .where(Subscription.user_id == user_id)
            .order_by(Subscription.created_at.desc())
            .limit(1)
        )
        subscription = sub_result.scalar_one_or_none()

        # Get payments
        pay_result = await session.execute(
            select(Payment)
            .where(Payment.user_id == user_id)
            .order_by(Payment.created_at.desc())
            .limit(20)
        )
        payments = pay_result.scalars().all()

        # Get recent spreads
        spread_result = await session.execute(
            select(TarotSpread)
            .where(TarotSpread.user_id == user_id)
            .order_by(TarotSpread.created_at.desc())
            .limit(10)
        )
        spreads = spread_result.scalars().all()

        return UserDetail(
            id=user.id,
            telegram_id=user.telegram_id,
            username=user.username,
            birth_date=user.birth_date,
            zodiac_sign=user.zodiac_sign,
            birth_time=user.birth_time.strftime("%H:%M") if user.birth_time else None,
            birth_city=user.birth_city,
            timezone=user.timezone,
            notifications_enabled=user.notifications_enabled,
            notification_hour=user.notification_hour,
            is_premium=user.is_premium,
            premium_until=user.premium_until,
            daily_spread_limit=user.daily_spread_limit,
            tarot_spread_count=user.tarot_spread_count,
            detailed_natal_purchased_at=user.detailed_natal_purchased_at,
            created_at=user.created_at,
            subscription=SubscriptionInfo.model_validate(subscription) if subscription else None,
            payments=[PaymentHistoryItem.model_validate(p) for p in payments],
            recent_spreads=[TarotSpreadHistoryItem.model_validate(s) for s in spreads],
        )


    async def update_user_subscription(
        session: AsyncSession,
        user_id: int,
        request: UpdateSubscriptionRequest,
    ) -> bool:
        """Update user subscription status."""
        result = await session.execute(
            select(User).where(User.id == user_id)
        )
        user = result.scalar_one_or_none()
        if not user:
            return False

        now = datetime.now(timezone.utc)

        if request.action == "activate":
            user.is_premium = True
            user.premium_until = now + timedelta(days=30)
            user.daily_spread_limit = 20
        elif request.action == "cancel":
            user.is_premium = False
            user.premium_until = None
            user.daily_spread_limit = 1
        elif request.action == "extend" and request.days:
            if user.premium_until and user.premium_until > now:
                user.premium_until = user.premium_until + timedelta(days=request.days)
            else:
                user.is_premium = True
                user.premium_until = now + timedelta(days=request.days)
                user.daily_spread_limit = 20

        await session.commit()
        return True


    async def gift_to_user(
        session: AsyncSession,
        user_id: int,
        request: GiftRequest,
    ) -> bool:
        """Give gift to user."""
        result = await session.execute(
            select(User).where(User.id == user_id)
        )
        user = result.scalar_one_or_none()
        if not user:
            return False

        now = datetime.now(timezone.utc)

        if request.gift_type == "premium_days":
            if user.premium_until and user.premium_until > now:
                user.premium_until = user.premium_until + timedelta(days=request.value)
            else:
                user.is_premium = True
                user.premium_until = now + timedelta(days=request.value)
                user.daily_spread_limit = 20
        elif request.gift_type == "detailed_natal":
            user.detailed_natal_purchased_at = now
        elif request.gift_type == "tarot_spreads":
            user.daily_spread_limit = user.daily_spread_limit + request.value

        await session.commit()
        return True


    async def bulk_action(
        session: AsyncSession,
        request: BulkActionRequest,
    ) -> BulkActionResponse:
        """Perform bulk action on users."""
        success = 0
        failed = 0
        errors = []

        for user_id in request.user_ids:
            try:
                result = await session.execute(
                    select(User).where(User.id == user_id)
                )
                user = result.scalar_one_or_none()
                if not user:
                    failed += 1
                    errors.append(f"User {user_id} not found")
                    continue

                now = datetime.now(timezone.utc)

                if request.action == "activate_premium":
                    user.is_premium = True
                    user.premium_until = now + timedelta(days=30)
                    user.daily_spread_limit = 20
                elif request.action == "cancel_premium":
                    user.is_premium = False
                    user.premium_until = None
                    user.daily_spread_limit = 1
                elif request.action == "gift_spreads" and request.value:
                    user.daily_spread_limit = user.daily_spread_limit + request.value
                # ban/unban would require an is_banned field

                success += 1
            except Exception as e:
                failed += 1
                errors.append(f"User {user_id}: {str(e)}")

        await session.commit()
        return BulkActionResponse(
            success_count=success,
            failed_count=failed,
            errors=errors,
        )
    ```
  </action>
  <verify>
    - Import src.admin.services.users works
    - Functions have correct signatures
  </verify>
  <done>User management service with CRUD and bulk operations</done>
</task>

<task type="auto">
  <name>Task 3: User management API endpoints</name>
  <files>
    - src/admin/router.py
  </files>
  <action>
    Add user management endpoints to src/admin/router.py:

    ```python
    from fastapi import Path, Query
    from src.admin.services.users import (
        list_users, get_user_detail, update_user_subscription,
        gift_to_user, bulk_action
    )
    from src.admin.schemas import (
        UserListResponse, UserDetail,
        UpdateSubscriptionRequest, GiftRequest,
        BulkActionRequest, BulkActionResponse
    )

    @admin_router.get("/users", response_model=UserListResponse)
    async def users_list(
        page: int = Query(1, ge=1),
        page_size: int = Query(20, ge=1, le=100),
        search: str | None = Query(None),
        zodiac_sign: str | None = Query(None),
        is_premium: bool | None = Query(None),
        has_detailed_natal: bool | None = Query(None),
        sort_by: str = Query("created_at"),
        sort_order: str = Query("desc"),
        session: AsyncSession = Depends(get_session),
        current_admin: Admin = Depends(get_current_admin),
    ):
        """List users with filters and pagination."""
        return await list_users(
            session,
            page=page,
            page_size=page_size,
            search=search,
            zodiac_sign=zodiac_sign,
            is_premium=is_premium,
            has_detailed_natal=has_detailed_natal,
            sort_by=sort_by,
            sort_order=sort_order,
        )

    @admin_router.get("/users/{user_id}", response_model=UserDetail)
    async def user_detail(
        user_id: int = Path(...),
        session: AsyncSession = Depends(get_session),
        current_admin: Admin = Depends(get_current_admin),
    ):
        """Get detailed user info."""
        user = await get_user_detail(session, user_id)
        if not user:
            raise HTTPException(status_code=404, detail="User not found")
        return user

    @admin_router.patch("/users/{user_id}/subscription")
    async def update_subscription(
        user_id: int = Path(...),
        request: UpdateSubscriptionRequest = ...,
        session: AsyncSession = Depends(get_session),
        current_admin: Admin = Depends(get_current_admin),
    ):
        """Update user subscription (activate/cancel/extend)."""
        success = await update_user_subscription(session, user_id, request)
        if not success:
            raise HTTPException(status_code=404, detail="User not found")
        return {"status": "ok"}

    @admin_router.post("/users/{user_id}/gift")
    async def gift_user(
        user_id: int = Path(...),
        request: GiftRequest = ...,
        session: AsyncSession = Depends(get_session),
        current_admin: Admin = Depends(get_current_admin),
    ):
        """Give gift to user (premium days, detailed natal, spreads)."""
        success = await gift_to_user(session, user_id, request)
        if not success:
            raise HTTPException(status_code=404, detail="User not found")
        return {"status": "ok"}

    @admin_router.post("/users/bulk", response_model=BulkActionResponse)
    async def users_bulk_action(
        request: BulkActionRequest,
        session: AsyncSession = Depends(get_session),
        current_admin: Admin = Depends(get_current_admin),
    ):
        """Perform bulk action on multiple users."""
        return await bulk_action(session, request)
    ```

    Add imports at top:
    ```python
    from fastapi import Path, Query
    from src.admin.services.users import (
        list_users, get_user_detail, update_user_subscription,
        gift_to_user, bulk_action
    )
    from src.admin.schemas import (
        UserListResponse, UserDetail,
        UpdateSubscriptionRequest, GiftRequest,
        BulkActionRequest, BulkActionResponse
    )
    ```
  </action>
  <verify>
    - App starts without errors
    - GET /admin/users returns paginated list
    - GET /admin/users/1 returns user detail or 404
    - PATCH /admin/users/1/subscription works
    - POST /admin/users/1/gift works
  </verify>
  <done>User management API endpoints working</done>
</task>

</tasks>

<verification>
1. App starts without import errors
2. GET /admin/users returns UserListResponse with pagination
3. Search by telegram_id and username works
4. Filters by zodiac_sign, is_premium work
5. GET /admin/users/{id} returns full user detail with history
6. PATCH subscription and POST gift endpoints work
7. Bulk action endpoint processes multiple users
</verification>

<success_criteria>
- Users list with pagination (20 per page default)
- Search by telegram_id or username
- Filter by zodiac sign, premium status, detailed natal
- User detail shows all info + payment history + spread history
- Subscription management (activate/cancel/extend)
- Gift functionality (premium days, natal, spreads)
- Bulk actions for multiple users
</success_criteria>

<output>
After completion, create `.planning/phases/09-admin-panel/09-04-SUMMARY.md`
</output>
