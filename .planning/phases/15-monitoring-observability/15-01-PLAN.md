---
phase: 15-monitoring-observability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/models/ai_usage.py
  - src/db/models/__init__.py
  - src/monitoring/__init__.py
  - src/monitoring/metrics.py
  - src/monitoring/health.py
  - src/main.py
  - alembic/versions/xxx_add_ai_usage.py
autonomous: true

must_haves:
  truths:
    - "/health endpoint возвращает JSON со статусом всех сервисов"
    - "/metrics endpoint возвращает Prometheus format"
    - "AIUsage таблица существует в БД для записи cost data"
  artifacts:
    - path: "src/db/models/ai_usage.py"
      provides: "AIUsage SQLAlchemy model"
      contains: "class AIUsage"
    - path: "src/monitoring/metrics.py"
      provides: "Custom Prometheus metrics"
      contains: "adtrobot_"
    - path: "src/monitoring/health.py"
      provides: "Health check functions"
      exports: ["check_database", "check_scheduler", "check_openrouter", "check_telegram_bot"]
  key_links:
    - from: "src/main.py"
      to: "src/monitoring/metrics.py"
      via: "instrumentator setup"
      pattern: "Instrumentator"
    - from: "src/main.py"
      to: "src/monitoring/health.py"
      via: "health endpoint import"
      pattern: "check_database"
---

<objective>
Создание базовой инфраструктуры мониторинга: AIUsage model для cost tracking, Prometheus metrics definitions, и расширенный /health endpoint.

Purpose: Фундамент для всей системы мониторинга - без этого невозможно записывать costs и собирать метрики.
Output: Работающие /health и /metrics endpoints, AIUsage таблица в БД.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/main.py
@src/db/models/__init__.py
@src/db/models/base.py
@src/services/scheduler.py
@src/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: AIUsage model + Alembic migration</name>
  <files>src/db/models/ai_usage.py, src/db/models/__init__.py, alembic/versions/xxx_add_ai_usage.py</files>
  <action>
1. Создать `src/db/models/ai_usage.py`:
```python
"""AI usage tracking model for cost analytics."""
from datetime import datetime
from sqlalchemy import Column, DateTime, Float, ForeignKey, Integer, String
from sqlalchemy.sql import func
from src.db.models.base import Base

class AIUsage(Base):
    """Tracks AI API usage for cost analytics and unit economics."""
    __tablename__ = "ai_usage"

    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=True)  # nullable for system operations
    created_at = Column(DateTime, default=func.now(), index=True)
    operation = Column(String(50), index=True)  # horoscope, tarot, natal_chart, card_of_day, celtic_cross
    model = Column(String(100))  # openai/gpt-4o-mini
    prompt_tokens = Column(Integer, default=0)
    completion_tokens = Column(Integer, default=0)
    total_tokens = Column(Integer, default=0)
    cost_dollars = Column(Float, nullable=True)  # from OpenRouter response or calculated
    generation_id = Column(String(100), nullable=True)  # OpenRouter generation ID
    latency_ms = Column(Integer, nullable=True)  # request duration
```

2. Добавить в `src/db/models/__init__.py`:
- Import: `from src.db.models.ai_usage import AIUsage`
- Add to `__all__`: `"AIUsage"`

3. Создать Alembic migration:
```bash
cd /Users/kirill/Desktop/AdtroBot && alembic revision --autogenerate -m "add_ai_usage_table"
```

Формат migration файла будет автогенерирован Alembic.
  </action>
  <verify>
- `alembic upgrade head` выполняется без ошибок
- `SELECT * FROM ai_usage LIMIT 1;` не падает (таблица существует)
  </verify>
  <done>AIUsage model создан, migration применена, таблица существует в БД.</done>
</task>

<task type="auto">
  <name>Task 2: Prometheus metrics module + instrumentator</name>
  <files>src/monitoring/__init__.py, src/monitoring/metrics.py, src/main.py</files>
  <action>
1. Создать `src/monitoring/__init__.py` (пустой файл с docstring):
```python
"""Monitoring module: metrics, health checks, cost tracking."""
```

2. Создать `src/monitoring/metrics.py`:
```python
"""Custom Prometheus metrics for AdtroBot."""
from prometheus_client import Counter, Gauge, Histogram

# === Request Metrics ===
REQUESTS_TOTAL = Counter(
    "adtrobot_requests_total",
    "Total HTTP requests",
    labelnames=["handler", "method", "status"]
)

ERRORS_TOTAL = Counter(
    "adtrobot_errors_total",
    "Total errors by type",
    labelnames=["handler", "error_type"]
)

# === AI Operation Metrics ===
AI_REQUEST_DURATION = Histogram(
    "adtrobot_ai_request_duration_seconds",
    "AI request duration in seconds",
    labelnames=["operation", "model"],
    buckets=[0.5, 1.0, 2.5, 5.0, 10.0, 30.0, 60.0]
)

AI_TOKENS_TOTAL = Counter(
    "adtrobot_ai_tokens_total",
    "Total AI tokens used",
    labelnames=["operation", "model", "token_type"]  # token_type: prompt/completion
)

AI_COST_TOTAL = Counter(
    "adtrobot_ai_cost_dollars_total",
    "Total AI cost in dollars",
    labelnames=["operation", "model"]
)

AI_REQUESTS_TOTAL = Counter(
    "adtrobot_ai_requests_total",
    "Total AI requests",
    labelnames=["operation", "model", "status"]  # status: success/error
)

# === Active Users Metrics ===
ACTIVE_USERS = Gauge(
    "adtrobot_active_users",
    "Active users count",
    labelnames=["period"]  # dau/wau/mau
)

# === Business Metrics ===
SUBSCRIPTION_CONVERSIONS = Counter(
    "adtrobot_subscription_conversions_total",
    "Total subscription conversions"
)

REVENUE_TOTAL = Counter(
    "adtrobot_revenue_rubles_total",
    "Total revenue in rubles"
)

# === Queue Metrics ===
QUEUE_DEPTH = Gauge(
    "adtrobot_queue_depth",
    "Background queue depth",
    labelnames=["status"]  # pending/failed/completed
)

# === Health Metrics ===
HEALTH_CHECK_STATUS = Gauge(
    "adtrobot_health_check_status",
    "Health check status (1=healthy, 0=unhealthy)",
    labelnames=["check"]  # database/scheduler/openrouter/telegram
)
```

3. Установить зависимости (если не установлены):
```bash
pip install prometheus-fastapi-instrumentator prometheus-client
```
Добавить в requirements.txt:
```
prometheus-fastapi-instrumentator>=7.0.0
prometheus-client>=0.20.0
```

4. Обновить `src/main.py`:
- После imports добавить:
```python
from prometheus_fastapi_instrumentator import Instrumentator
from prometheus_client import make_asgi_app
```

- После `app = FastAPI(lifespan=lifespan)` добавить:
```python
# Prometheus instrumentation
instrumentator = Instrumentator(
    should_group_status_codes=True,
    should_ignore_untemplated=True,
    should_instrument_requests_inprogress=True,
    excluded_handlers=["/health", "/metrics"],
    inprogress_name="adtrobot_requests_in_progress",
    inprogress_labels=True,
)
instrumentator.instrument(app)

# Mount /metrics endpoint (no auth - standard Prometheus scraping)
metrics_app = make_asgi_app()
app.mount("/metrics", metrics_app)
```
  </action>
  <verify>
- `curl http://localhost:8000/metrics` возвращает Prometheus format (текст с `# HELP`, `# TYPE`)
- Метрики содержат `adtrobot_` prefix
  </verify>
  <done>Prometheus metrics определены, instrumentator настроен, /metrics endpoint доступен.</done>
</task>

<task type="auto">
  <name>Task 3: Расширенный /health endpoint с checks</name>
  <files>src/monitoring/health.py, src/main.py</files>
  <action>
1. Создать `src/monitoring/health.py`:
```python
"""Health check functions for /health endpoint."""
import asyncio
import time
from dataclasses import dataclass

import httpx
import structlog
from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession

from src.monitoring.metrics import HEALTH_CHECK_STATUS

logger = structlog.get_logger()


@dataclass
class HealthCheckResult:
    """Result of a single health check."""
    name: str
    healthy: bool
    message: str | None = None
    latency_ms: float | None = None


async def check_database(session: AsyncSession, timeout: float = 3.0) -> HealthCheckResult:
    """Check database connection with timeout."""
    start = time.monotonic()
    try:
        await asyncio.wait_for(
            session.execute(text("SELECT 1")),
            timeout=timeout
        )
        latency = (time.monotonic() - start) * 1000
        HEALTH_CHECK_STATUS.labels(check="database").set(1)
        return HealthCheckResult("database", True, latency_ms=round(latency, 2))
    except asyncio.TimeoutError:
        HEALTH_CHECK_STATUS.labels(check="database").set(0)
        return HealthCheckResult("database", False, "Timeout")
    except Exception as e:
        HEALTH_CHECK_STATUS.labels(check="database").set(0)
        return HealthCheckResult("database", False, str(e))


async def check_scheduler(timeout: float = 2.0) -> HealthCheckResult:
    """Check APScheduler status."""
    try:
        from src.services.scheduler import get_scheduler
        scheduler = get_scheduler()
        if scheduler.running:
            jobs_count = len(scheduler.get_jobs())
            HEALTH_CHECK_STATUS.labels(check="scheduler").set(1)
            return HealthCheckResult("scheduler", True, f"{jobs_count} jobs scheduled")
        HEALTH_CHECK_STATUS.labels(check="scheduler").set(0)
        return HealthCheckResult("scheduler", False, "Scheduler not running")
    except Exception as e:
        HEALTH_CHECK_STATUS.labels(check="scheduler").set(0)
        return HealthCheckResult("scheduler", False, str(e))


async def check_openrouter(timeout: float = 10.0) -> HealthCheckResult:
    """Check OpenRouter API availability."""
    start = time.monotonic()
    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            resp = await client.get("https://openrouter.ai/api/v1/models")
            latency = (time.monotonic() - start) * 1000
            if resp.status_code == 200:
                HEALTH_CHECK_STATUS.labels(check="openrouter").set(1)
                return HealthCheckResult("openrouter", True, latency_ms=round(latency, 2))
            HEALTH_CHECK_STATUS.labels(check="openrouter").set(0)
            return HealthCheckResult("openrouter", False, f"Status {resp.status_code}")
    except Exception as e:
        HEALTH_CHECK_STATUS.labels(check="openrouter").set(0)
        return HealthCheckResult("openrouter", False, str(e))


async def check_telegram_bot(timeout: float = 10.0) -> HealthCheckResult:
    """Check Telegram Bot API connection."""
    start = time.monotonic()
    try:
        from src.bot.bot import get_bot
        from src.config import settings

        if not settings.telegram_bot_token:
            # Token not configured - not an error in dev
            HEALTH_CHECK_STATUS.labels(check="telegram").set(1)
            return HealthCheckResult("telegram", True, "Token not configured (dev mode)")

        bot = get_bot()
        me = await asyncio.wait_for(bot.get_me(), timeout=timeout)
        latency = (time.monotonic() - start) * 1000
        HEALTH_CHECK_STATUS.labels(check="telegram").set(1)
        return HealthCheckResult("telegram", True, f"@{me.username}", latency_ms=round(latency, 2))
    except asyncio.TimeoutError:
        HEALTH_CHECK_STATUS.labels(check="telegram").set(0)
        return HealthCheckResult("telegram", False, "Timeout")
    except Exception as e:
        HEALTH_CHECK_STATUS.labels(check="telegram").set(0)
        return HealthCheckResult("telegram", False, str(e))


async def run_all_checks(session: AsyncSession) -> tuple[bool, list[HealthCheckResult]]:
    """Run all health checks in parallel.

    Returns:
        Tuple of (all_healthy, list of results)
    """
    checks = await asyncio.gather(
        check_database(session, timeout=3.0),
        check_scheduler(timeout=2.0),
        check_openrouter(timeout=10.0),
        check_telegram_bot(timeout=10.0),
    )
    all_healthy = all(c.healthy for c in checks)
    return all_healthy, list(checks)
```

2. Обновить `/health` endpoint в `src/main.py`:
- Заменить существующий простой `/health` на расширенный:
```python
from fastapi import Depends, status
from fastapi.responses import JSONResponse
from src.monitoring.health import run_all_checks
from src.db.engine import get_session

@app.get("/health")
async def health_check(
    session: AsyncSession = Depends(get_session),
) -> JSONResponse:
    """
    Comprehensive health check endpoint.
    Returns 200 if all checks pass, 503 if any fails.
    """
    all_healthy, checks = await run_all_checks(session)

    response_data = {
        "status": "healthy" if all_healthy else "unhealthy",
        "checks": {
            c.name: {
                "healthy": c.healthy,
                "message": c.message,
                "latency_ms": c.latency_ms,
            }
            for c in checks
        }
    }

    return JSONResponse(
        content=response_data,
        status_code=status.HTTP_200_OK if all_healthy else status.HTTP_503_SERVICE_UNAVAILABLE,
    )
```

НЕ забыть:
- Добавить import `from sqlalchemy.ext.asyncio import AsyncSession` в начало main.py
- Удалить старый простой `async def health()` endpoint
  </action>
  <verify>
- `curl http://localhost:8000/health` возвращает JSON:
```json
{
  "status": "healthy",
  "checks": {
    "database": {"healthy": true, "message": null, "latency_ms": 1.23},
    "scheduler": {"healthy": true, "message": "3 jobs scheduled", "latency_ms": null},
    "openrouter": {"healthy": true, "message": null, "latency_ms": 150.5},
    "telegram": {"healthy": true, "message": "@botname", "latency_ms": 200.3}
  }
}
```
- HTTP status 200 если все healthy, 503 если что-то failed
  </verify>
  <done>/health возвращает детальный JSON со статусом всех сервисов и HTTP коды по состоянию.</done>
</task>

</tasks>

<verification>
1. `alembic upgrade head` - миграция применяется без ошибок
2. `curl http://localhost:8000/metrics` - возвращает Prometheus format с adtrobot_* метриками
3. `curl http://localhost:8000/health` - возвращает JSON с checks для database, scheduler, openrouter, telegram
4. Приложение стартует без ошибок: `cd /Users/kirill/Desktop/AdtroBot && python -c "from src.main import app; print('OK')"`
</verification>

<success_criteria>
- AIUsage таблица создана в PostgreSQL
- /metrics endpoint возвращает Prometheus format
- /health endpoint возвращает детальный JSON с 4 checks
- Все adtrobot_* метрики определены и регистрируются
</success_criteria>

<output>
After completion, create `.planning/phases/15-monitoring-observability/15-01-SUMMARY.md`
</output>
