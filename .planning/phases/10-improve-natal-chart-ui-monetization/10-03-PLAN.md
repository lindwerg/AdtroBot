---
phase: 10-improve-natal-chart-ui-monetization
plan: 03
type: execute
wave: 2
depends_on: ["10-02"]
files_modified:
  - src/services/ai/prompts.py
  - src/services/ai/client.py
  - src/services/ai/validators.py
autonomous: true

must_haves:
  truths:
    - "DetailedNatalPrompt генерирует 3000-5000 слов по секциям"
    - "generate_detailed_natal_interpretation() генерирует полную интерпретацию"
    - "Детальная интерпретация кэшируется на 7 дней"
    - "Валидатор проверяет минимальную длину секций"
  artifacts:
    - path: "src/services/ai/prompts.py"
      provides: "DetailedNatalPrompt with 8 sections"
      contains: "class DetailedNatalPrompt"
    - path: "src/services/ai/client.py"
      provides: "generate_detailed_natal_interpretation method"
      contains: "generate_detailed_natal_interpretation"
    - path: "src/services/ai/validators.py"
      provides: "validate_detailed_natal function"
      contains: "validate_detailed_natal"
  key_links:
    - from: "src/services/ai/client.py"
      to: "src/services/ai/prompts.py"
      via: "DetailedNatalPrompt usage"
      pattern: "DetailedNatalPrompt"
---

<objective>
Создать AI промпт и генератор для детальной интерпретации натальной карты (3000-5000 слов).

Purpose: Полная интерпретация личности - премиум продукт за 199 рублей.
Output: DetailedNatalPrompt, generate_detailed_natal_interpretation(), валидатор, кэш 7 дней.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-improve-natal-chart-ui-monetization/10-RESEARCH.md
@src/services/ai/prompts.py
@src/services/ai/client.py
@src/services/ai/validators.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Создать DetailedNatalPrompt</name>
  <files>src/services/ai/prompts.py</files>
  <action>
Добавить в конец файла prompts.py новый класс DetailedNatalPrompt:

```python
@dataclass
class DetailedNatalPrompt:
    """Prompt for detailed natal chart interpretation (3000-5000 words).

    Uses sectioned generation for reliable long-form output.
    """

    SYSTEM = """Ты - профессиональный астролог с 20-летним опытом.
Пиши детальную интерпретацию натальной карты для клиента.

СТИЛЬ:
- Обращайся на "ты", тепло и профессионально
- Используй астрологические термины, но объясняй их простым языком
- Приводи конкретные примеры из жизни ("Это может проявляться как...")
- Создавай эффект узнавания себя
- НЕ упоминай, что ты AI
- НЕ используй фразы "как AI", "языковая модель", "я не могу"
- НЕ извиняйся и не отказывайся

СТРУКТУРА КАЖДОЙ СЕКЦИИ:
1. Описание позиции (знак, дом, градус)
2. Психологическое значение
3. Конкретные проявления в жизни
4. Сильные стороны
5. Зоны роста и рекомендации"""

    SECTIONS = [
        {
            "id": "core",
            "title": "ЯДРО ЛИЧНОСТИ: Солнце, Луна, Асцендент",
            "focus": "Большая Тройка - кто ты в глубине души, твои эмоции, как тебя видят другие",
            "min_words": 600,
            "planets": ["sun", "moon", "ascendant"],
        },
        {
            "id": "mind",
            "title": "МЫШЛЕНИЕ И КОММУНИКАЦИЯ: Меркурий",
            "focus": "Как ты думаешь, учишься, обрабатываешь информацию, общаешься",
            "min_words": 400,
            "planets": ["mercury"],
        },
        {
            "id": "love",
            "title": "ЛЮБОВЬ И ОТНОШЕНИЯ: Венера",
            "focus": "Как ты любишь, что ценишь в партнере, твой стиль в отношениях",
            "min_words": 500,
            "planets": ["venus"],
        },
        {
            "id": "drive",
            "title": "ЭНЕРГИЯ И ДЕЙСТВИЕ: Марс",
            "focus": "Как ты действуешь, добиваешься целей, выражаешь агрессию и страсть",
            "min_words": 400,
            "planets": ["mars"],
        },
        {
            "id": "growth",
            "title": "РОСТ И УДАЧА: Юпитер",
            "focus": "Где тебе везет, твои возможности для роста и расширения",
            "min_words": 400,
            "planets": ["jupiter"],
        },
        {
            "id": "lessons",
            "title": "УРОКИ И ОТВЕТСТВЕННОСТЬ: Сатурн",
            "focus": "Твои кармические уроки, где нужна дисциплина, зоны зрелости",
            "min_words": 400,
            "planets": ["saturn"],
        },
        {
            "id": "transformation",
            "title": "ТРАНСФОРМАЦИЯ: Уран, Нептун, Плутон",
            "focus": "Поколенческие влияния, глубинные трансформации, духовность",
            "min_words": 400,
            "planets": ["uranus", "neptune", "pluto"],
        },
        {
            "id": "summary",
            "title": "СИНТЕЗ И РЕКОМЕНДАЦИИ",
            "focus": "Главные темы твоей карты, сильные стороны, практические советы",
            "min_words": 500,
            "planets": [],
        },
    ]

    @staticmethod
    def format_natal_for_prompt(natal_data: dict) -> str:
        """Format natal data for inclusion in prompt."""
        planets = natal_data["planets"]
        angles = natal_data["angles"]

        lines = []
        # Planets
        for name, data in planets.items():
            sign_ru = data.get("sign_ru", data["sign"])
            degree = data["degree"]
            lines.append(f"{name.title()}: {sign_ru} {degree:.0f}°")

        # Angles
        lines.append(f"Асцендент: {angles['ascendant']['sign_ru']} {angles['ascendant']['degree']:.0f}°")
        lines.append(f"MC: {angles['mc']['sign_ru']} {angles['mc']['degree']:.0f}°")

        # Top aspects
        aspects = natal_data["aspects"][:10]
        if aspects:
            lines.append("\nОсновные аспекты:")
            for asp in aspects:
                lines.append(f"  {asp['planet1_ru']} {asp['aspect_ru']} {asp['planet2_ru']}")

        time_note = "известно" if natal_data["time_known"] else "неизвестно (12:00)"
        lines.append(f"\nВремя рождения: {time_note}")

        return "\n".join(lines)

    @classmethod
    def section_prompt(cls, section: dict, natal_data: dict) -> str:
        """Generate prompt for a specific section."""
        natal_text = cls.format_natal_for_prompt(natal_data)

        return f"""Напиши секцию "{section['title']}" для детальной интерпретации натальной карты.

Фокус этой секции: {section['focus']}

ВАЖНО: Напиши МИНИМУМ {section['min_words']} слов. Это платный продукт, клиент ожидает глубокий анализ.

Натальная карта:
{natal_text}

Пиши детально, с примерами из жизни. Начни сразу с содержания, без повторения заголовка."""
```
  </action>
  <verify>
```bash
cd /Users/kirill/Desktop/AdtroBot && python -c "
from src.services.ai.prompts import DetailedNatalPrompt
print('Sections count:', len(DetailedNatalPrompt.SECTIONS))
print('Total min words:', sum(s['min_words'] for s in DetailedNatalPrompt.SECTIONS))
print('First section:', DetailedNatalPrompt.SECTIONS[0]['title'])
"
```
Должно вывести: 8 секций, ~3600 минимум слов, первая секция "ЯДРО ЛИЧНОСТИ".
  </verify>
  <done>DetailedNatalPrompt создан с 8 секциями и минимум 3600 слов.</done>
</task>

<task type="auto">
  <name>Task 2: Добавить валидатор для детальной интерпретации</name>
  <files>src/services/ai/validators.py</files>
  <action>
Добавить функцию валидации в validators.py:

```python
def validate_detailed_natal(text: str, min_chars: int = 15000) -> bool:
    """Validate detailed natal interpretation.

    Args:
        text: AI-generated interpretation
        min_chars: Minimum characters (default 15000 ~ 3000 words Russian)

    Returns:
        True if valid
    """
    if not text or len(text.strip()) < min_chars:
        return False

    # Check for AI self-references
    ai_patterns = [
        "как ai", "как ии", "языковая модель", "искусственный интеллект",
        "я не могу", "я не в состоянии", "к сожалению, я"
    ]
    text_lower = text.lower()
    for pattern in ai_patterns:
        if pattern in text_lower:
            return False

    # Check has multiple sections (at least 5 section-like headers)
    section_markers = text.count("\n\n")
    if section_markers < 5:
        return False

    return True
```

Также добавить валидатор секции:

```python
def validate_detailed_natal_section(text: str, min_words: int) -> bool:
    """Validate a single section of detailed natal interpretation.

    Args:
        text: Section text
        min_words: Minimum word count for this section

    Returns:
        True if valid
    """
    if not text:
        return False

    # Count words (rough approximation for Russian)
    word_count = len(text.split())
    if word_count < min_words * 0.8:  # Allow 20% tolerance
        return False

    # Check for AI patterns
    ai_patterns = ["как ai", "как ии", "языковая модель"]
    text_lower = text.lower()
    for pattern in ai_patterns:
        if pattern in text_lower:
            return False

    return True
```
  </action>
  <verify>
```bash
cd /Users/kirill/Desktop/AdtroBot && python -c "
from src.services.ai.validators import validate_detailed_natal, validate_detailed_natal_section

# Test full validation
long_text = 'Тест ' * 4000  # ~4000 words
short_text = 'Тест ' * 100
print('Long text valid:', validate_detailed_natal(long_text))
print('Short text valid:', validate_detailed_natal(short_text))

# Test section validation
section = 'Слово ' * 500
short_section = 'Слово ' * 50
print('Section 400 words valid:', validate_detailed_natal_section(section, 400))
print('Short section valid:', validate_detailed_natal_section(short_section, 400))
"
```
  </verify>
  <done>Валидаторы validate_detailed_natal и validate_detailed_natal_section добавлены.</done>
</task>

<task type="auto">
  <name>Task 3: Добавить generate_detailed_natal_interpretation в AI client</name>
  <files>src/services/ai/client.py</files>
  <action>
1. В начале файла client.py добавить импорт DetailedNatalPrompt (рядом с другими импортами из prompts):
```python
from src.services.ai.prompts import (
    CardOfDayPrompt,
    DetailedNatalPrompt,  # ADD THIS
    HoroscopePrompt,
    ...
)
```

2. Добавить импорт валидатора (рядом с другими импортами из validators):
```python
from src.services.ai.validators import (
    validate_detailed_natal_section,  # ADD THIS
    validate_horoscope,
    ...
)
```

3. ПОСЛЕ существующих кэш-переменных (найти строки `_horoscope_cache`, `_premium_cache` и т.д.) добавить кэш для детальной интерпретации:
```python
# Cache for detailed natal interpretations (7 days)
_detailed_natal_cache: dict[int, tuple[str, float]] = {}
DETAILED_NATAL_CACHE_TTL = 604800  # 7 days
```

4. В класс AIService добавить метод generate_detailed_natal_interpretation.
   Метод должен использовать self._generate() который уже существует в классе.
   Сигнатура self._generate():
   ```python
   async def _generate(self, system_prompt: str, user_prompt: str, max_tokens: int = 1500) -> str | None
   ```

   Добавить метод:
```python
async def generate_detailed_natal_interpretation(
    self,
    user_id: int,
    natal_data: dict,
) -> str | None:
    """Generate detailed natal chart interpretation (3000-5000 words).

    Uses sectioned generation for reliable long-form output.
    Caches result for 7 days.

    Args:
        user_id: User ID for caching
        natal_data: FullNatalChartResult dict

    Returns:
        Full interpretation text or None on failure
    """
    import time

    # Check cache
    if user_id in _detailed_natal_cache:
        cached_text, cached_time = _detailed_natal_cache[user_id]
        if time.time() - cached_time < DETAILED_NATAL_CACHE_TTL:
            logger.info("detailed_natal_cache_hit", user_id=user_id)
            return cached_text

    logger.info("generating_detailed_natal", user_id=user_id)

    sections_text = []

    for section in DetailedNatalPrompt.SECTIONS:
        section_prompt = DetailedNatalPrompt.section_prompt(section, natal_data)

        # Generate section with higher max_tokens
        max_tokens = max(1500, section["min_words"] * 3)  # ~3 tokens per word

        for attempt in range(3):  # Retry up to 3 times
            try:
                response = await self._generate(
                    system_prompt=DetailedNatalPrompt.SYSTEM,
                    user_prompt=section_prompt,
                    max_tokens=max_tokens,
                )

                if response and validate_detailed_natal_section(response, section["min_words"]):
                    sections_text.append(f"## {section['title']}\n\n{response}")
                    break
                else:
                    logger.warning(
                        "detailed_natal_section_short",
                        section=section["id"],
                        attempt=attempt + 1,
                        length=len(response) if response else 0,
                    )
            except Exception as e:
                logger.error(
                    "detailed_natal_section_error",
                    section=section["id"],
                    error=str(e),
                )

            if attempt == 2:
                # Use whatever we got on last attempt
                if response:
                    sections_text.append(f"## {section['title']}\n\n{response}")
                else:
                    logger.error("detailed_natal_section_failed", section=section["id"])

    if not sections_text:
        return None

    full_text = "\n\n".join(sections_text)

    # Cache result
    _detailed_natal_cache[user_id] = (full_text, time.time())
    logger.info(
        "detailed_natal_generated",
        user_id=user_id,
        total_chars=len(full_text),
        sections=len(sections_text),
    )

    return full_text
```
  </action>
  <verify>
```bash
cd /Users/kirill/Desktop/AdtroBot && python -c "
from src.services.ai import get_ai_service
from src.services.ai.client import _detailed_natal_cache, DETAILED_NATAL_CACHE_TTL
import inspect

service = get_ai_service()

# Check method exists
print('Method exists:', hasattr(service, 'generate_detailed_natal_interpretation'))

# Check signature
sig = inspect.signature(service.generate_detailed_natal_interpretation)
print('Parameters:', list(sig.parameters.keys()))

# Check cache variables exist
print('Cache TTL:', DETAILED_NATAL_CACHE_TTL)
print('Cache dict type:', type(_detailed_natal_cache).__name__)

# Verify _generate method exists (used by new method)
print('_generate exists:', hasattr(service, '_generate'))
"
```
Должно показать: Method exists: True, Parameters: ['user_id', 'natal_data'], Cache TTL: 604800, _generate exists: True
  </verify>
  <done>generate_detailed_natal_interpretation добавлен с секционной генерацией и 7-дневным кэшем.</done>
</task>

</tasks>

<verification>
1. DetailedNatalPrompt.SECTIONS содержит 8 секций
2. Минимальная сумма слов секций >= 3600
3. validate_detailed_natal проверяет длину >= 15000 символов
4. validate_detailed_natal_section проверяет минимум слов с 20% толерантностью
5. generate_detailed_natal_interpretation существует в AIService
6. Кэш TTL = 7 дней (604800 секунд)
7. Метод использует self._generate() для API вызовов
</verification>

<success_criteria>
- [ ] DetailedNatalPrompt создан с 8 секциями
- [ ] validate_detailed_natal и validate_detailed_natal_section работают
- [ ] generate_detailed_natal_interpretation генерирует по секциям
- [ ] Кэш 7 дней для детальной интерпретации
- [ ] Retry логика для секций (до 3 попыток)
- [ ] Использует существующий self._generate() метод
</success_criteria>

<output>
After completion, create `.planning/phases/10-improve-natal-chart-ui-monetization/10-03-SUMMARY.md`
</output>
