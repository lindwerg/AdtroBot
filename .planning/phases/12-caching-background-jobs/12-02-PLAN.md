---
phase: 12-caching-background-jobs
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - src/services/horoscope_cache.py
  - src/services/scheduler.py
  - src/main.py
autonomous: true

must_haves:
  truths:
    - "HoroscopeCacheService returns cached horoscope from PostgreSQL in <500ms"
    - "Per-key asyncio.Lock prevents duplicate generation for same zodiac sign"
    - "Background job generates 12 horoscopes every 12 hours (00:00 and 12:00 Moscow time)"
    - "View count increments on each horoscope fetch"
    - "Old horoscopes (date < today) are cleaned up before generation"
    - "Cache is warmed from PostgreSQL on application startup"
  artifacts:
    - path: "src/services/horoscope_cache.py"
      provides: "HoroscopeCacheService with get_horoscope, per-key locking, view tracking"
      exports: ["HoroscopeCacheService", "get_horoscope_cache_service"]
    - path: "src/services/scheduler.py"
      provides: "Background job for daily horoscope generation every 12 hours"
      contains: "generate_daily_horoscopes"
    - path: "src/main.py"
      provides: "Cache warming on startup via lifespan"
      contains: "warm_horoscope_cache"
  key_links:
    - from: "src/services/horoscope_cache.py"
      to: "src/db/models/horoscope_cache.py"
      via: "import HoroscopeCache, HoroscopeView"
      pattern: "from src.db.models import HoroscopeCache"
    - from: "src/services/horoscope_cache.py"
      to: "src/services/ai/client.py"
      via: "import get_ai_service"
      pattern: "from src.services.ai import get_ai_service"
    - from: "src/services/scheduler.py"
      to: "src/services/horoscope_cache.py"
      via: "import HoroscopeCacheService for background job"
      pattern: "from src.services.horoscope_cache import get_horoscope_cache_service"
    - from: "src/main.py"
      to: "src/services/horoscope_cache.py"
      via: "import for cache warming"
      pattern: "from src.services.horoscope_cache import get_horoscope_cache_service"
---

<objective>
Implement HoroscopeCacheService with PostgreSQL persistence, background generation every 12 hours, and cache warming on startup

Purpose: Horoscopes load instantly from cache (<500ms), AI generation happens in background at 00:00 and 12:00 Moscow time, cache is preloaded on restart
Output: Cache service with per-key locking + scheduled job every 12h + startup cache warming
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/12-caching-background-jobs/12-CONTEXT.md
@.planning/phases/12-caching-background-jobs/12-RESEARCH.md

@src/services/ai/client.py
@src/services/scheduler.py
@src/bot/utils/zodiac.py
@src/db/engine.py
@src/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HoroscopeCacheService with per-key locking</name>
  <files>src/services/horoscope_cache.py</files>
  <action>
Create new file `src/services/horoscope_cache.py` implementing:

**HoroscopeCacheService class:**

1. **__init__:**
   - Create fixed dict of 12 asyncio.Lock objects (one per zodiac sign from ZODIAC_SIGNS)
   - NO defaultdict to prevent memory leaks

2. **get_horoscope(zodiac_sign: str, session: AsyncSession) -> str | None:**
   - Acquire lock for this zodiac_sign
   - Inside lock:
     - Query HoroscopeCache WHERE zodiac_sign=sign AND horoscope_date=today
     - If cached: increment view count, return content
     - If not cached (rare - first startup, after failure):
       - Get AIService via get_ai_service()
       - Generate horoscope with retry (3 attempts, 5/10/30 sec backoff)
       - Save to HoroscopeCache
       - Increment view count
       - Return content
   - If all retries fail, return None

3. **_increment_view(session: AsyncSession, zodiac_sign: str, view_date: date):**
   - UPSERT into horoscope_views: increment view_count or insert with count=1
   - Use PostgreSQL ON CONFLICT DO UPDATE

4. **Singleton pattern:**
   - `_instance: HoroscopeCacheService | None = None`
   - `get_horoscope_cache_service() -> HoroscopeCacheService`

**Key implementation details from RESEARCH.md:**
- Use `from datetime import date` for today comparison
- Lock acquired BEFORE cache check (prevents race condition)
- Use structlog for logging
- Retry backoff: asyncio.sleep(backoff) with [5, 10, 30] seconds
- Import ZODIAC_SIGNS from src.bot.utils.zodiac

Reference: 12-RESEARCH.md Pattern 2 (Per-Key asyncio.Lock) and Code Example "Cache Service with Per-Key Locking"
  </action>
  <verify>
`python -c "from src.services.horoscope_cache import HoroscopeCacheService, get_horoscope_cache_service; svc = get_horoscope_cache_service(); print(len(svc._locks))"` outputs "12"
  </verify>
  <done>
HoroscopeCacheService exists with 12 locks, get_horoscope method, and singleton getter
  </done>
</task>

<task type="auto">
  <name>Task 2: Add background job for horoscope generation every 12 hours</name>
  <files>src/services/scheduler.py</files>
  <action>
Add to existing `src/services/scheduler.py`:

1. **New async function `generate_daily_horoscopes()`:**
   - Import async_session_maker from src.db.engine
   - Import ZODIAC_SIGNS from src.bot.utils.zodiac
   - Import get_horoscope_cache_service from src.services.horoscope_cache

   - Get today's date
   - Delete old horoscopes: `DELETE FROM horoscope_cache WHERE horoscope_date < today`

   - Loop through ZODIAC_SIGNS.items() (12 signs):
     - **IMPORTANT: Use HoroscopeCacheService for generation:**
       ```python
       cache_service = get_horoscope_cache_service()
       async with async_session_maker() as session:
           for sign_en, sign_ru in ZODIAC_SIGNS.items():
               result = await cache_service.get_horoscope(sign_en, session)
               if result:
                   logger.info("Horoscope generated", sign=sign_en)
               else:
                   logger.error("Failed to generate horoscope", sign=sign_en)
       ```
     - This ensures: per-key locking, retry logic, view tracking all handled by HoroscopeCacheService
     - Do NOT duplicate AI generation logic here

   - All generation is sequential (one sign after another)

2. **Register job in get_scheduler() with 12-hour schedule:**
   After existing jobs, add:
   ```python
   _scheduler.add_job(
       generate_daily_horoscopes,
       CronTrigger(hour='0,12', minute=0, timezone="Europe/Moscow"),
       id="generate_daily_horoscopes",
       replace_existing=True,
       misfire_grace_time=3600,  # 1 hour grace
   )
   ```

**Key points:**
- `hour='0,12'` runs at 00:00 AND 12:00 Moscow time (PERF-03 requirement: every 12 hours)
- CronTrigger with timezone="Europe/Moscow"
- replace_existing=True prevents duplicate jobs on restart
- misfire_grace_time=3600 handles server downtime
- Delegates to HoroscopeCacheService (no duplicate generation logic)

Reference: 12-RESEARCH.md Pattern 3 (APScheduler CronTrigger)
  </action>
  <verify>
1. `python -c "from src.services.scheduler import generate_daily_horoscopes; print('OK')"` outputs "OK"
2. `python -c "from src.services.scheduler import get_scheduler; s = get_scheduler(); jobs = [j for j in s.get_jobs() if j.id == 'generate_daily_horoscopes']; print('12h' if jobs and '0,12' in str(jobs[0].trigger) else 'FAIL')"` outputs "12h"
  </verify>
  <done>
generate_daily_horoscopes job registered to run every 12 hours (00:00 and 12:00 Moscow time), uses HoroscopeCacheService
  </done>
</task>

<task type="auto">
  <name>Task 3: Add cache warming on application startup</name>
  <files>src/main.py</files>
  <action>
Modify `src/main.py` to warm horoscope cache on startup:

1. **Add imports:**
   ```python
   from src.services.horoscope_cache import get_horoscope_cache_service
   from src.bot.utils.zodiac import ZODIAC_SIGNS
   from src.db.engine import async_session_maker
   ```

2. **Create async function `warm_horoscope_cache()`:**
   ```python
   async def warm_horoscope_cache():
       """Preload horoscope cache from PostgreSQL on startup (PERF-07)."""
       logger = structlog.get_logger()
       cache_service = get_horoscope_cache_service()

       logger.info("Warming horoscope cache...")
       async with async_session_maker() as session:
           for sign_en, sign_ru in ZODIAC_SIGNS.items():
               try:
                   await cache_service.get_horoscope(sign_en, session)
                   logger.debug("Cache warmed", sign=sign_en)
               except Exception as e:
                   logger.warning("Failed to warm cache", sign=sign_en, error=str(e))

       logger.info("Horoscope cache warming complete")
   ```

3. **Call in lifespan context manager (startup):**
   Find the lifespan function (or create if not exists). Add cache warming after database initialization:
   ```python
   @asynccontextmanager
   async def lifespan(app: Application):
       # ... existing startup code (DB, scheduler, etc.)

       # Warm horoscope cache (PERF-07)
       await warm_horoscope_cache()

       yield

       # ... existing shutdown code
   ```

   If bot uses `on_startup` handlers instead:
   ```python
   async def on_startup(application: Application):
       # ... existing startup code
       await warm_horoscope_cache()
   ```

**Key points:**
- Calls get_horoscope for all 12 signs on startup
- This loads existing horoscopes from PostgreSQL into memory (via the singleton service)
- If no cached horoscope exists, it will generate on-demand (graceful degradation)
- Use try/except per sign so one failure doesn't block others
  </action>
  <verify>
`grep -q "warm_horoscope_cache" src/main.py && echo "OK" || echo "MISSING"`
  </verify>
  <done>
Cache warming function exists and is called on application startup, preloading all 12 zodiac signs from PostgreSQL
  </done>
</task>

</tasks>

<verification>
1. HoroscopeCacheService has 12 fixed locks (no defaultdict)
2. get_horoscope uses lock BEFORE checking cache
3. View count increments via UPSERT
4. Scheduler has generate_daily_horoscopes job with CronTrigger(hour='0,12')
5. Job cleans up old horoscopes before generating new ones
6. Job uses HoroscopeCacheService (not direct AI calls)
7. Cache is warmed on application startup via warm_horoscope_cache()
</verification>

<success_criteria>
- HoroscopeCacheService singleton with per-key locking for 12 signs
- get_horoscope returns cached content or generates on-demand with retry
- View tracking via UPSERT on each fetch
- Background job scheduled at 00:00 AND 12:00 Moscow time (every 12 hours)
- Background job uses HoroscopeCacheService for single-point-of-entry
- Old cache entries cleaned up before generation
- Cache warmed from PostgreSQL on application startup
</success_criteria>

<output>
After completion, create `.planning/phases/12-caching-background-jobs/12-02-SUMMARY.md`
</output>
