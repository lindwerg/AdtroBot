---
phase: 12-caching-background-jobs
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - src/services/horoscope_cache.py
  - src/services/scheduler.py
autonomous: true

must_haves:
  truths:
    - "HoroscopeCacheService returns cached horoscope from PostgreSQL in <500ms"
    - "Per-key asyncio.Lock prevents duplicate generation for same zodiac sign"
    - "Background job generates 12 horoscopes at 00:00 Moscow time"
    - "View count increments on each horoscope fetch"
    - "Old horoscopes (date < today) are cleaned up before generation"
  artifacts:
    - path: "src/services/horoscope_cache.py"
      provides: "HoroscopeCacheService with get_horoscope, per-key locking, view tracking"
      exports: ["HoroscopeCacheService", "get_horoscope_cache_service"]
    - path: "src/services/scheduler.py"
      provides: "Background job for daily horoscope generation"
      contains: "generate_daily_horoscopes"
  key_links:
    - from: "src/services/horoscope_cache.py"
      to: "src/db/models/horoscope_cache.py"
      via: "import HoroscopeCache, HoroscopeView"
      pattern: "from src.db.models import HoroscopeCache"
    - from: "src/services/horoscope_cache.py"
      to: "src/services/ai/client.py"
      via: "import get_ai_service"
      pattern: "from src.services.ai import get_ai_service"
    - from: "src/services/scheduler.py"
      to: "src/services/horoscope_cache.py"
      via: "import for background job"
      pattern: "from src.services.horoscope_cache import"
---

<objective>
Implement HoroscopeCacheService with PostgreSQL persistence and background generation

Purpose: Horoscopes load instantly from cache (<500ms), AI generation happens in background at 00:00
Output: Cache service with per-key locking + scheduled job for daily generation
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/12-caching-background-jobs/12-CONTEXT.md
@.planning/phases/12-caching-background-jobs/12-RESEARCH.md

@src/services/ai/client.py
@src/services/scheduler.py
@src/bot/utils/zodiac.py
@src/db/engine.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HoroscopeCacheService with per-key locking</name>
  <files>src/services/horoscope_cache.py</files>
  <action>
Create new file `src/services/horoscope_cache.py` implementing:

**HoroscopeCacheService class:**

1. **__init__:**
   - Create fixed dict of 12 asyncio.Lock objects (one per zodiac sign from ZODIAC_SIGNS)
   - NO defaultdict to prevent memory leaks

2. **get_horoscope(zodiac_sign: str, session: AsyncSession) -> str | None:**
   - Acquire lock for this zodiac_sign
   - Inside lock:
     - Query HoroscopeCache WHERE zodiac_sign=sign AND horoscope_date=today
     - If cached: increment view count, return content
     - If not cached (rare - first startup, after failure):
       - Get AIService via get_ai_service()
       - Generate horoscope with retry (3 attempts, 5/10/30 sec backoff)
       - Save to HoroscopeCache
       - Increment view count
       - Return content
   - If all retries fail, return None

3. **_increment_view(session: AsyncSession, zodiac_sign: str, view_date: date):**
   - UPSERT into horoscope_views: increment view_count or insert with count=1
   - Use PostgreSQL ON CONFLICT DO UPDATE

4. **Singleton pattern:**
   - `_instance: HoroscopeCacheService | None = None`
   - `get_horoscope_cache_service() -> HoroscopeCacheService`

**Key implementation details from RESEARCH.md:**
- Use `from datetime import date` for today comparison
- Lock acquired BEFORE cache check (prevents race condition)
- Use structlog for logging
- Retry backoff: asyncio.sleep(backoff) with [5, 10, 30] seconds
- Import ZODIAC_SIGNS from src.bot.utils.zodiac

Reference: 12-RESEARCH.md Pattern 2 (Per-Key asyncio.Lock) and Code Example "Cache Service with Per-Key Locking"
  </action>
  <verify>
`python -c "from src.services.horoscope_cache import HoroscopeCacheService, get_horoscope_cache_service; svc = get_horoscope_cache_service(); print(len(svc._locks))"` outputs "12"
  </verify>
  <done>
HoroscopeCacheService exists with 12 locks, get_horoscope method, and singleton getter
  </done>
</task>

<task type="auto">
  <name>Task 2: Add background job for daily horoscope generation</name>
  <files>src/services/scheduler.py</files>
  <action>
Add to existing `src/services/scheduler.py`:

1. **New async function `generate_daily_horoscopes()`:**
   - Import async_session_maker from src.db.engine
   - Import HoroscopeCache from src.db.models
   - Import ZODIAC_SIGNS from src.bot.utils.zodiac
   - Import get_ai_service from src.services.ai

   - Get today's date
   - Delete old horoscopes: `DELETE FROM horoscope_cache WHERE horoscope_date < today`

   - Loop through ZODIAC_SIGNS.items() (12 signs):
     - Check if horoscope already exists for today (skip if yes - restart scenario)
     - Generate with retry (3 attempts, backoff [300, 600, 1800] seconds = 5/10/30 min)
     - Save to HoroscopeCache
     - Log success/failure per sign

   - All generation is sequential (one sign after another)
   - Use async with async_session_maker() as session

2. **Register job in get_scheduler():**
   After existing jobs, add:
   ```python
   _scheduler.add_job(
       generate_daily_horoscopes,
       CronTrigger(hour=0, minute=0, timezone="Europe/Moscow"),
       id="generate_daily_horoscopes",
       replace_existing=True,
       misfire_grace_time=3600,  # 1 hour grace
   )
   ```

**Key points from RESEARCH.md:**
- CronTrigger with timezone="Europe/Moscow" for 00:00 Moscow time
- replace_existing=True prevents duplicate jobs on restart
- misfire_grace_time=3600 handles server downtime
- Sequential generation (not parallel) to avoid API rate limits
- Check if already exists before generating (restart scenario)

Reference: 12-RESEARCH.md Pattern 3 (APScheduler CronTrigger) and Code Example "Background Generation Job"
  </action>
  <verify>
1. `python -c "from src.services.scheduler import generate_daily_horoscopes; print('OK')"` outputs "OK"
2. `python -c "from src.services.scheduler import get_scheduler; s = get_scheduler(); print([j.id for j in s.get_jobs()])"` includes "generate_daily_horoscopes"
  </verify>
  <done>
generate_daily_horoscopes job registered to run at 00:00 Moscow time with retry logic
  </done>
</task>

</tasks>

<verification>
1. HoroscopeCacheService has 12 fixed locks (no defaultdict)
2. get_horoscope uses lock BEFORE checking cache
3. View count increments via UPSERT
4. Scheduler has generate_daily_horoscopes job with CronTrigger
5. Job cleans up old horoscopes before generating new ones
6. Retry logic follows 5/10/30 min backoff for background job
</verification>

<success_criteria>
- HoroscopeCacheService singleton with per-key locking for 12 signs
- get_horoscope returns cached content or generates on-demand with retry
- View tracking via UPSERT on each fetch
- Background job scheduled at 00:00 Moscow time
- Old cache entries cleaned up daily
</success_criteria>

<output>
After completion, create `.planning/phases/12-caching-background-jobs/12-02-SUMMARY.md`
</output>
